\documentstyle{book}
%\input{html.sty}
%\htmladdtonavigation
%   {\begin{rawhtml}
% <A HREF="http://heasarc.gsfc.nasa.gov/docs/software/fitsio/fitsio.html">FITSIO Home</A>
%    \end{rawhtml}}
\oddsidemargin=0.25in
\evensidemargin=0.00in
\textwidth=6.0in
\topmargin=0.0in
\textheight=8.75in
\parindent=0cm
\parskip=0.2cm
\begin{document}

\begin{titlepage}
\normalsize
\vspace*{4.0cm}
\begin{center}
{\Huge \bf CFITSIO User's Guide}\\
\end{center}
\medskip 
\medskip 
\begin{center}
{\LARGE \bf An Interface to FITS Format Files}\\
\end{center}
\begin{center}
{\LARGE \bf for C Programmers}\\
\end{center}
\medskip
\medskip
\begin{center}
{\Large Version 1.2\\}
\end{center}
\bigskip
\vskip 3.0cm
\begin{center}
{Dr. William D. Pence\\
HEASARC\\
Code 662\\
Goddard Space Flight Center\\
Greenbelt, MD 20771\\
USA}
\end{center}

\vfill
\bigskip
\begin{center}
{\Large March 1997\\}
\end{center}
\vfill
\end{titlepage}

\begin{titlepage}
\vspace*{7.6cm}
\vfill
\end{titlepage}

\pagenumbering{roman}

\tableofcontents

\chapter{Introduction }
\pagenumbering{arabic}

CFITSIO is a machine-independent library of routines for reading and
writing data files in the FITS (Flexible Image Transport System) data
format. CFITSIO is written entirely in ANSI-C and provides the same
functions as in the previously available Fortran FITSIO library. This
library was written to provide a powerful yet simple interface for
accessing FITS files which will run on most commonly used computers and
workstations. This version of CFITSIO supports all the features
described in the official NOST definition of the FITS format and can
read and write all the currently defined types of extensions, including
ASCII tables (TABLE), Binary tables (BINTABLE) and IMAGE extensions.
The CFITSIO routines insulate the programmer from having to deal with
the complicated formatting details in the FITS file, however, it is
assumed that users have a general knowledge about the structure and
usage of FITS files.

This new ANSI-C library should not be confused with the previously
available set of C macros which provide a C-callable interface to the
Fortran FITSIO routines.  These older macros are contained in the
cfitsio.h file that is distributed along with the Fortran FITSIO source
files.  These macros will continue to be supported for a limited
period, but they should be considered obsolete.  New FITS application
software should be written using the new CFITSIO interface described
here.

The CFITSIO package was developed for use by the HEASARC (High Energy
Astrophysics Science Archive Research Center) at the NASA Goddard Space
Flight Center to convert various existing and newly acquired
astronomical data sets into FITS format and to further analyze data
already in FITS format.  The latest version of the CFITSIO source code,
documentation, and example programs are all available on the World-Wide
Web at the following URL:

\begin{verbatim}
        http://heasarc.gsfc.nasa.gov/fitsio
\end{verbatim}
CFITSIO also can be obtained from the HEASARC via anonymous ftp from
{\bf legacy.gsfc.nasa.gov}    (or, 128.183.126.108) in the
{\bf software/fitsio/c} subdirectory.

Any questions, bug reports, or suggested enhancements related to the CFITSIO
package should be sent to the author:

\begin{verbatim}
        Dr. William Pence                 Telephone:  (301) 286-4599
        HEASARC                           E-mail: pence@tetra.gsfc.nasa.gov
        Code 662
        NASA/Goddard Space Flight Center
        Greenbelt, MD 20771
        USA
\end{verbatim}
This User's Guide assumes that readers already have a general
understanding of the definition and structure of FITS format files.
For further information about FITS formats, please obtain a copy of the
`FITS User's Guide' and the `NOST FITS Standard', which are available
from the NASA, Science Office of Standards and Technology at the
address given below.  Both of these documents are available
electronically from their Web site and via anonymous ftp at
nssdc.gsfc.nasa.gov in the /pub/fits directory. Any questions about
FITS formats should be directed to the NOST, at:

\begin{verbatim}
        NASA, Science Office of Standards and Technology
        Code 633.2,
        Goddard Space Flight Center
        Greenbelt MD 20771
        USA
        WWW: http://ssdoo.gsfc.nasa.gov/astro/fits/fits_home.html
        E-mail: fits@nssdca.gsfc.nasa.gov
        (301) 286-2899
\end{verbatim}
CFITSIO users may also be interested in the FTOOLS package of programs
that can be used to manipulate and analyze FITS format files.
Information about FTOOLS can be obtained on the WWW at:

\begin{verbatim}
        http://heasarc.gsfc.nasa.gov/docs/software/ftools/ftools_menu.html
\end{verbatim}
or via anonymous FTP at:

\begin{verbatim}
        legacy.gsfc.nasa.gov  /software/ftools/release
\end{verbatim}

\chapter{ Creating the CFITSIO Library }


\section{Building the Library}

The CFITSIO code is contained in 30 source files (*.c) and 3 header
files (*.h). On VAX/VMS systems 2 assembly-code files (vmsieeed.mar and
vmsieeer.mar) are also needed.

The CFITSIO library is built on Unix systems by typing:

\begin{verbatim}
   > configure
   > make
\end{verbatim}
at the operating system prompt.  The `configure' command customizes the
Makefile for the particular system, then the `make' command builds the
library.

On VAX/VMS and ALPHA/VMS systems, the make.com command file may be
used to build the cfitsio.olb object library.  Execute this command
file by typing '@make' on the command line.

On DOS-based PC computers, the makepc.bat file gives an example of how
to build the CFITSIO library.  This file will probably need to be
editted to include the appropriate command switches if a different C
compiler or linker is used.

The MacOS version of the cfitsio library can be built by (1) unbinhex
and unstuff cfitsio\_mac.sit.hqx, and (2) for the PPC,  load CFitsio
PPCLibrary.(pi) into CodeWarrior 10+ and make.  This builds the cfitsio
library for PPC.  If you would like to build the test program, load
CFitsio PPC testprog.(pi) into CodeWarrior 10+ and make.

CFITSIO has currently been tested on the following platforms:

\begin{verbatim}
   Operating System          Compiler
   ----------------          --------
   Sun OS                     gcc and cc (3.0.1)
   Sun Solaris                gcc and cc
   Silicon Graphics IRIX      gcc and cc
   DECstation  Ultrix         gcc
   Dec Alpha OSF/1            gcc
   Dec Alpha OpenVMS          cc with /float=gfloat or /float=ieee options
   DEC VAX/VMS                gcc and cc
   Linux running on IBM PC    gcc
   IBM PC w/ Windows 95       Borland C++ V4.5
   MacOS 7.1 or greater       Metrowerks 10.+
\end{verbatim}
CFITSIO will probably run on most other Unix platforms without
modification.  Cray supercomputers and IBM mainframe computers are
currently not supported.


\section{Testing the Library}

The CFITSIO library should be tested by building and running
the testprog.c program that is included with the release.
On Unix systems (assuming the gcc compiler is being used), type:

\begin{verbatim}
    % gcc -o testprog testprog.c -L. -lcfitsio -lm
    % testprog > testprog.lis
    % diff testprog.lis testprog.out
    % cmp testprog.fit testprog.std
\end{verbatim}
 On VMS systems,
(assuming cc is the name of the C compiler command), type:

\begin{verbatim}
    $ cc testprog.c
    $ link testprog, cfitsio/lib
    $ run testprog
\end{verbatim}
The testprog program should produce a FITS file called `testprog.fit'
that is identical to the testprog.std FITS file included in this
release.  The diagnostic messages (which were piped to the file
testprog.lis in the Unix example) should be identical to the listing
contained in the file testprog.out.  The 'diff' and 'cmp' commands
shown above should not report any differences in the files.

The program speed.c that is included with CFITSIO may be used to
approximately measure the maximum possible throughput (in MB per
second) for writing and reading FITS files with CFITSIO on a particular
computer system.


\section{Getting Started with CFITSIO}

In order to effectively use the CFITSIO library as quickly as possible,
it is recommended that new users follow these steps:

1.  Read the following `FITS Primer' chapter for a brief
overview of the structure of FITS files.  This is especially important
for users who have not previously dealt with the FITS table and image
extensions.

2.  Write a simple program to read or write a FITS file using the Basic
Interface routines described in Chapter 6.  Remember to include the
`fitsio.h' file at the beginning of the program.

3.  Refer to the cookbook.c program that is included with this release
for examples of routines that perform various common FITS file
operations.

4. Read Chapters 4 and 5 to become familiar with the conventions and
advanced features of the CFITSIO interface.  Note especially the
section on code optimization.

5.  Scan through the more extensive set of routines that are provided
in the `Advanced Interface', as described in Chapter 7.  These routines
perform more specialized functions than are provided by the Basic
Interface routines.


\section{Example Program}

The following listing shows an example of how to use the CFITSIO
routines in a C program.  Refer to the cookbook.c program that
is included with the CFITSIO distribution for examples of other
FITS programs.


\begin{verbatim}
#include "fitsio.h"  /* required by every program that uses CFITSIO  */
main()
{   /* Create a FITS primary array containing a 2-D image */
    fitsfile *fptr;       /* pointer to the FITS file; defined in fitsio.h */
    int status, ii, jj;
    long  fpixel, nelements, array[200][300], exposure;

    /* Initialize FITS image parameters */
    char filename[] = "atestfil.fit";             /* name for new FITS file */
    int bitpix   =  16;         /* 16-bit short signed integer pixel values */
    long naxis    =   2;        /* 2-dimensional image                      */
    long naxes[2] = { 300, 200 };   /* image is 300 pixels wide by 200 rows */
    status = 0;         /* initialize status before calling fitsio routines */

    if (fits_create_file(&fptr, filename, &status)) /* create new FITS file */
        return( status );

    /* Write the required keywords for the primary array image */
    if ( fits_create_img(fptr,  bitpix, naxis, naxes, &status) )
         return( status );

    /* Initialize the values in the image with a linear ramp function */
    for (jj = 0; jj < naxes[1]; jj++)
        for (ii = 0; ii < naxes[0]; ii++)
            array[jj][ii] = ii + jj;

    fpixel = 1;                               /* first pixel to write      */
    nelements = naxes[0] * naxes[1];          /* number of pixels to write */

    /* Write the array of long integers (after converting them to short) */
    if ( fits_write_img(fptr, TLONG, fpixel, nelements, array[0], &status) )
        return( status );

    /* Write another optional keyword; must pass the ADDRESS of the value */
    exposure = 1500.;
    if ( fits_write_key(fptr, TLONG, "EXPOSURE", &exposure,
         "Total Exposure Time", &status) )
         return( status );

    fits_close_file(fptr, &status);            /* close the file */
    return( status );
}
\end{verbatim}

\chapter{  A FITS Primer }

This section gives a brief overview of the structure of FITS files.
Users should refer to the documentation available from the NOST, as
described in the introduction, for more detailed information on FITS
formats.

FITS was first developed in the late 1970's as a standard data
interchange format between various astronomical observatories.  Since
then FITS has become the defacto standard data format supported by most
astronomical data analysis software packages.

A FITS file consists of one or more Header + Data Units (HDUs), where
the first HDU is called the `Primary HDU', or `Primary Array'.  The
primary array contains an N-dimensional array of pixels, such as a 1-D
spectrum, a 2-D image, or a 3-D data cube.  Five different primary
datatypes are supported: Unsigned 8-bit bytes, 16 and 32-bit signed
integers, and 32 and 64-bit floating point reals.  FITS also has a
convention for storing 16 and 32-bit unsigned integers (see the later
section entitled `Unsigned Integers' for more details). The primary HDU
may also consist of only a header with a null array containing no
data pixels.

Any number of additional HDUs may follow the primary array; these
additional HDUs are called FITS `extensions'.  There are currently 3
types of extensions defined by the FITS standard:

\begin{verbatim}
  Image Extension - a N-dimensional array of pixels, like in a primary array

  ASCII Table Extension - rows and columns of data in ASCII character format

  Binary Table Extension - rows and columns of data in binary representation
\end{verbatim}
In each case the HDU consists of an ASCII Header Unit followed by an optional
Data Unit.  For historical reasons, each Header or Data unit must be an
exact multiple of 2880 8-bit bytes long.  Any unused space is padded
with fill characters (ASCII blanks or NULs depending on the type of unit).

Each Header Unit consists of any number of 80-character keyword records
or `card images' (reminiscent of the 80-column punched cards which
were prevalent when the FITS standard was developed) which have the
general form:

\begin{verbatim}
  KEYNAME = value / comment string
\end{verbatim}
The keyword names may be up to 8 characters long and can only contain
uppercase letters, the digits 0-9, the hyphen, and the underscore
character. The keyword name is (usually) followed by an equals sign and
a space character (= ) in columns 9 - 10 of the record, followed by the
value of the keyword which may be either an integer, a floating point
number, a character string (enclosed in single quotes), or a boolian
value (the letter T or F). The last keyword in the header is always the
`END' keyword which has no value or comment fields. There are many
rules governing the exact format of a keyword record (see the NOST FITS
Standard) so it is better to rely on standard interface software like
FITSIO to correctly construct or to parse the keyword records rather
than try to deal directly with the raw FITS formats.

Each Header Unit begins with a series of required keywords which depend
on the type of HDU.  These required keywords specify the size and
format of the following Data Unit.  The header many contain other
optional keywords to describe other aspects of the data, such as the
units or scaling values.  Other COMMENT or HISTORY keywords are also
frequently added to further document the data file.

The optional Data Unit immediately follows the last 2880-byte block in
the Header Unit.  Some HDUs do not have a Data Unit and only consist of
the Header Unit.

If there is more than one HDU in the FITS file, then the Header Unit of
the next HDU immediately follows the last 2880-byte block of the
previous Data Unit (or Header Unit if there is no Data Unit).


\chapter{  Basic CFITSIO Conventions }


\section{CFITSIO definitions}

Any program that uses the CFITSIO interface must include the fitsio.h
header file with the statement

\begin{verbatim}
  #include "fitsio.h"
\end{verbatim}
This file contains the prototypes for
all the CFITSIO user interface routines as well as various symbolic
names or constants used in the interface.  It also defines a C
structure named `fitsfile' that is used by CFITSIO to store the
relevant parameters that define the format of a particular FITS file.
Application programs must define a pointer to this structure for each
FITS file that is to be opened with a declaration
at the beginning of the program similar to:

\begin{verbatim}
  fitsfile *fptr;
\end{verbatim}
This structure is initialized (i.e., memory is allocated
for the structure) when the FITS file is first opened or created
with the fits\_open\_file or fits\_create\_file routines.  This fitsfile
pointer is then passed as the first argument to every other CFITSIO
routine that operates on the FITS file.  The cookbook.c program
that is included with the CFITSIO library contains example programs
illustrating this usage.


\section{Current Header Data Unit (CHDU)}

A basic concept used throughout CFITSIO is that of the current Header
Data Unit (CHDU) within the FITS file. The CFITSIO routines which read
or write information only operate on the CHDU.  When a FITS file is first
created or opened the CHDU is automatically defined to be the first HDU
(i.e., the primary array).  CFITSIO routines are provided to move
to and open any other existing HDU within the FITS file or to append or
insert a new HDU in the FITS file which then becomes the CHDU.


\section{Routine Names}

All the CFITSIO routines have both a short name and a longer
descriptive name.  The short name is only 5 or 6 characters long and is
similar to the subroutine name in the Fortran-77 version of FITSIO.
The longer name is more descriptive and helps to document the source
code; these long names are defined as macros in the longnam.h header
file.  It is purely a matter of personal preference whether to use the
short or the long names since they are identical in terms of function
or efficiency.  The descriptions of the routines given in chapters 6
and 7 list both the long and short names.


\section{Routine Families and Datatypes}

Many of the CFITSIO routines come in families which differ only in the
datatype of the associated parameter(s).  The datatype of these
routines is indicated by the suffix of the routine name.  The short
routine names have a 1 or 2 character suffix (e.g., 'j' in 'ffpkyj')
while the long routine names have a 4 character or longer suffix
as shown in the following table:

\begin{verbatim}
    Long   Short  Data
    Names  Names  Type
    -----  -----  ----
    _bit     x    bit
    _byt     b    unsigned byte
    _sht     i    short integer
    _lng     j    long integer
    _usht    ui   unsigned short integer
    _ulng    uj   unsigned long integer
    _int     k    int integer
    _flt     e    real exponential floating point (float)
    _fixflt  f    real fixed-decimal format floating point (float)
    _dbl     d    double precision real floating-point (double)
    _fixdbl  g    double precision fixed-format floating point (double)
    _cmp     c    complex reals (pairs of float values)
    _dblcmp  m    double precision complex (pairs of double values)
    _log     l    logical (int)
    _str     s    character string
\end{verbatim}
The `int' datatype is often 2 bytes long on IBM PC compatible
systems and 4 bytes long on most other systems.  The Alpha/OSF systems
are unusual in that the `short', `int', and `long' integer datatypes
are 2, 4, and 8 bytes long, respectively.  Note that the FITS standard
only supports 2 and 4 byte intergers, so FITSIO always converts between
4 and 8 bytes when reading or writing `long' integers on Alpha/OSF systems.

When dealing with the FITS byte datatype, it is important to remember that
the raw values (before any scaling by the BSCALE and BZERO, or TSCALn
and TZEROn keyword values) in byte arrays (BITPIX = 8) or byte columns
(TFORMn = 'B') are interpreted as unsigned bytes with values ranging
from 0 to 255.  Some C compilers define a 'char' variable as signed, so
it is important to always explicitly declare a numeric char variable as
'unsigned char'.

The complex and double precision complex datatypes are not directly
supported in ANSI C, so these datatypes should be interpreted as pairs
of float or double values, respectively, where the first  value in each
pair is the real part, and the second is the imaginary part.


\section{Unsigned Integers}

Although FITS does not directly support unsigned integers as one of
its basic datatypes, FITS can still be used to efficiently store
unsigned integer data values in images and binary tables.  The
convention used in FITS files is to store the unsigned integers as
signed integers with an appropriate offset (as specified by the BZERO
or TZEROn keywords).  For example, to store unsigned 16-bit integer
values in a FITS image, the image would be defined as a signed 16-bit
integer (BITPIX keyword = 16) with the keywords BSCALE = 1.0 and BZERO
= 32768.  Thus the unsigned values of 0, 32768, and 65535 would be
physically stored in the FITS image as -32768, 0, and 32767,
respectively, and CFITSIO will automatically add the BZERO offset to
these values when they are read.  In the case of unsigned 32-bit
integers, the BITBIX keyword would be equal to 32 and BZERO would be
equal to 2147483648 (i.e. 2 raised to the 31st power).

The CFITSIO interface routines will efficiently and transparently apply
the appropriate offset in these cases, so in general, application
programs do not need to be concerned with how the unsigned values are
actually stored in the FITS file.  As a convenience for users, CFITSIO
has several predefined constants for the value of BITPIX  (USHORT\_IMG,
ULONG\_IMG) and for the TFORMn value in the case of binary tables (`U'
and `V') which programmers can use when creating FITS files containing
unsigned integer values.  For example, the following code fragment
illustrates how to write a FITS 1-D primary array of unsigned 16-bit
integers:

\begin{verbatim}
      unsigned short uarray[100];
      int naxis, status;
      long naxes[10], group, firstelem, nelements;
       ...
      status = 0;
      naxis = 1;
      naxes[0] = 100;
      fits_write_imghdr(fptr, USHORT_IMG, naxis, naxes, &status);

      group = 1;
      firstelem = 1;
      nelements = 100;
      fits_write_img_usht(fptr, group, firstelem, nelements,
                          uarray, &status);
       ...
\end{verbatim}
In the above example, the 2nd parameter in the call to
`fits\_write\_imghdr' tells CFITSIO to write the header keywords
appropriate for an array of 16-bit unsigned integers (i.e., BITPIX = 16
and BZERO = 32768).  Then the fits\_write\_img\_usht routine writes
the array of unsigned short integers (uarray) into the primary array of
the FITS file.  Similarly, a 32-bit unsigned integer image may be
created by setting the second parameter in fits\_write\_imghdr equal to
`ULONG\_IMG' and by calling the fits\_write\_img\_ulng routine to write
the array of unsigned long image pixel values.

An analogous set of routines are available for reading or writing
unsigned integer values in a FITS binary table extension.  When
specifying the TFORMn keyword value which defines the format of a
column, CFITSIO recognized 2 additional datatype codes besides those
already defined in the FITS standard: `U' meaning a 16-bit unsigned
integer column, and `V' for a 32-bit unsigned integer column.  It must
be stressed that these non-standard datatype codes are not actually
written into the FITS file, but instead, are just used internally
within CFITSIO.  The following code fragment illustrates how to use
these features:

\begin{verbatim}
      unsigned short uarray[100];
      unsigned long  varray[100];

      int colnum, tfields, status;
      long nrows, firstrow, firstelem, nelements;

      char extname[] = "Test_table";           /* extension name */

      /* define the name, datatype, and physical units for the 2 columns */
      char *ttype[] = { "Col_1", "Col_2" };
      char *tform[] = { "1U",      "1V"   };  /* special CFITSIO codes */
      char *tunit[] = { " ",        " "   };
       ...

           /* write the header keywords */
      status = 0;
      nrows = 1;
      tfields = 2
      fits_write_btblhdr(fptr, nrows, tfields, ttype, tform, tunit,
                extname, &status);

           /* write the unsigned shorts to the 1st column */
      colnum    = 1;
      firstrow  = 1;
      firstelem = 1;
      nelements = 100;
      fits_write_col_usht(fptr, colnum, firstrow, firstelem,
              nelements, uarray, &status);

           /* now write the unsigned longs to the 2nd column */
      colnum    = 2;
      fits_write_col_ulng(fptr, colnum, firstrow, firstelem,
              nelements, varray, &status);
       ...
\end{verbatim}
Note that the non-standard tform values for the 2 columns, `U' and `V',
tell CFITSIO to write the keywords appropriate for unsigned 16-bit and
unsigned 32-bit integers, respectively (i.e., TFORMn = '1I' and TSCALn
= 32678 for unsigned 16-bit integers, and TFORMn = '1J' and TSCALn =
2147483648 for unsigned 32-bit integers).  The calls to
fits\_write\_col\_usht and to fits\_write\_col\_ulng then write the
arrays of unsigned integer values to the columns.


\section{1's Based Index Numbers}

The CFITSIO parameters that specify a position in the FITS file, such as
row number, column number or HDU number, generally start with 1 as the
first value, rather than 0. This is the same convention that is used in
the Fortran version of FITSIO.


\section{Character Strings}

The character string values in a FITS header or in an ASCII column in a
FITS table extension are generally padded out with non-significant
space characters (ASCII 32) to fill up the header record or the column
width.  When reading a FITS string value, the  CFITSIO routines will
strip off these non-significant trailing spaces and will return a
null-terminated string value containing only the significant
characters.  Similarly, when writing string values to a FITS file the
CFITSIO routines expect to get a null-terminated string as input;
CFITSIO will pad the string with blanks if necessary before writing it
to the FITS file.  Note that leading spaces in a FITS string are
considered significant.

When calling CFITSIO routines that return a character string it is
vital that the size of the char array be large enough to hold the
entire string of characters, otherwise CFITSIO will overwrite whatever
memory locations follow the char array, possibly causing the program to
execute incorrectly.  This type of error can be very difficult to
debug, so programmers should always ensure that the char arrays are
allocated enough space to hold the longest possible string, {\bf
including} the terminating NULL character.  The fitsio.h file contains
the following defined constants which programmers are strongly
encouraged to use whenever they are allocating space for char arrays:

\begin{verbatim}
#define FLEN_KEYWORD    9  /* max length of a keyword */
#define FLEN_CARD      81  /* length of a FITS header card */
#define FLEN_VALUE     71  /* max length of a keyword value string */
#define FLEN_COMMENT   73  /* max length of a keyword comment string */
#define FLEN_ERRMSG    81  /* max length of a FITSIO error message */
#define FLEN_STATUS    31  /* max length of a FITSIO status text string */
\end{verbatim}
For example, then declaring a char array to hold the value string
of FITS keyword, use the following statment:

\begin{verbatim}
    char value[FLEN_VALUE];
\end{verbatim}


\section{Implicit Data Type Conversion}

Many of the CFITSIO data I/O routines have the ability to perform
implicit data type conversion.  This means that the data type of the
routine parameter does not need to be the same as the data type of the
value in the FITS file.  More specifically, the implicit data type
conversion will be performed for numerical data types when reading a
FITS header keyword value and when reading or writing values to or from
the primary array or a table column.  CFITSIO returns status =
NUM\_OVERFLOW (412) if the converted data value exceeds the range of
the output data type.  Data type conversion is not allowed when reading
or writing string (s), logical (l), complex (c), or double complex (m)
data types.

One feature of the CFITSIO routines is that they can operate on
a `X' (bit) column in a binary table as though it were a `B' (byte) column.
For example a `11X' datatype column can be interpreted the same
as a `2B' column (i.e., 2 unsigned 8-bit bytes).
In some instances, it can be more efficient to read and write whole
bytes at a time, rather than reading or writing each individual bit
(with the ffgcx and ffpclx routines).


\section{Data Scaling}

When reading numerical data values in the primary array or a
table column, the values will be scaled automatically by the BSCALE and
BZERO (or TSCALn and TZEROn) header values if they are
present in the header.  The scaled data that is returned to the reading
program will have

\begin{verbatim}
        output value = (FITS value) * BSCALE + BZERO
\end{verbatim}
(a corresponding formula using TSCALn and TZEROn is used when reading
from table columns).  In the case of integer output values the floating
point scaled value is truncated to an integer (not rounded to the
nearest integer).  The ffpscl and fftscl routines may be used to
override the scaling parameters defined in the header (e.g., to turn
off the scaling so that the program can read the raw unscaled values
from the FITS file).

When writing numerical data to the primary array or to a table
column the data values will generally be automatically inversely scaled
by the value of the BSCALE and BZERO (or TSCALn and TZEROn)
keyword values if they they exist in the header.  These keywords must
have been written to the header before any data is written for them to
have any immediate effect.  One may also use the ffpscl and fftscl
routines to define or override the scaling keywords in the header
(e.g., to turn off the scaling so that the program can write the raw
unscaled values into the FITS file). If scaling is performed, the
inverse scaled output value that is written into the FITS file will
have

\begin{verbatim}
         FITS value = ((input value) - BZERO) / BSCALE
\end{verbatim}
(a corresponding formula using TSCALn and TZEROn is used when
writing to table columns).  Rounding to the nearest integer, rather
than truncation, is performed when writing integer datatypes to the
FITS file.


\section{Error Status Values and the Error Message Stack}

Nearly all the CFITSIO routines return an error status value
in 2 ways: as the value of the last parameter in the function call,
and as the returned value of the function itself.  This provides
some flexibility in the way programmers can test if an error
occurred, as illustrated in the following 2 code fragments:

\begin{verbatim}
    if ( fits_write_record(fptr, card, &status) )
         printf(" Error occurred while writing keyword.");
\end{verbatim}
or,

\begin{verbatim}
    fits_write_record(fptr, card, &status);
    if ( status )
         printf(" Error occurred while writing keyword.");
\end{verbatim}
A listing of all the CFITSIO status code values and their symbolic
mnemonics is given at the end of this document.  Programmers are
encouraged to use the symbolic  mnemonics (defined in fitsio.h) rather
than the actual integer status values to improve the readability of
their code.

The CFITSIO library uses an `inherited status' convention for the
status parameter which means that if a routine is called with a
positive input value of the status parameter as input, then the routine
will exit immediately without changing the value of the status
parameter.  Thus, if one passes the status value returned from each
CFITSIO routine as input to the next CFITSIO routine, then whenever an
error is detected all further CFITSIO processing will cease.  This
convention can simplify the error checking in application programs
because it is not necessary to check the value of the status parameter
after every single CFITSIO routine call.  If a program contains a
sequence of several CFITSIO calls, one can just check the status value
after the last call.  Since the returned status values are generally
distinctive, it should be possible to determine which routine
originally returned the error status.

CFITSIO also maintains an internal stack of error messages
(80-character maximum length)  which in many cases provide a more
detailed explanation of the cause of the error than is provided by the
error status number alone.  It it recommended that the error message
stack be printed out whenever a program detects a CFITSIO error.  To do
this, call the ffgmsg routine repeatedly to get the successive messages
on the stack.  When the stack is empty ffgmsg will return a null value
(and a null string).  Note that this is a `First In -- First Out'
stack, so the oldest error message is returned first by ffgmsg.

In some situations programs may encounter a non-fatal CFITSIO error and
will want to continue processing.  An example is when a program fails
to find an optional keyword in the header and CFITSIO returns status =
KEY\_NO\_EXIST (202).  The program may ignore this error and reset
status = 0, however this may still leave error messages on the stack.
To clear the entire message stack in this situation, call the ffcmsg
routine.


\section{Variable-Length Arrays in Binary Tables}

CFITSIO provides easy-to-use support for reading and writing data in
variable length fields of a binary table. The variable length columns
have TFORMn keyword values of the form `1Pt(len)' where `t' is the
datatype code (e.g., I, J, E, D, etc.) and `len' is an integer
specifying the maximum length of the vector in the table.  If the value
of `len' is not specified when the table is created (e.g., if the TFORM
keyword value is simply specified as '1PE' instead of '1PE(400) ), then
CFITSIO will automatically scan the table when it is closed to
determine the maximum length of the vector and will append this value
to the TFORMn value.

The same routines which read and write data in an ordinary fixed length
binary table extension are also used for variable length fields,
however, the routine parameters take on a slightly different
interpretation as described below.

All the data in a variable length field is written into an area called
the `heap' which follows the main fixed-length FITS binary table. The
size of the heap, in bytes, is specified by the PCOUNT keyword in the
FITS header. When creating a new binary table, the initial value of
PCOUNT should usually be set to zero. CFITSIO will recompute the size of
the heap as the data is written and will automatically update the PCOUNT
keyword value when the table is closed. Thus, application programs
usually do not need to worry about the heap size, except when inserting
a new binary table HDU in front of other existing HDUs in the FITS file
(with ffibin). In this specific case the correct final value of PCOUNT
must be specified when the HDU is initially created so that the correct
amount of space will be inserted into the FITS file.

By default the heap data area starts immediately after the last row of
the fixed-length table.  (This default starting location may be
overridden by the THEAP keyword, but this is not recommended).  Thus
when writing variable length arrays the number of rows in the table
should be correctly specified (with the NAXIS2 keyword) at the time the
table is first created.  This differs from the simpler case of tables
that only contain fixed-length columns where the number of rows in the
table does not have to be explicitly defined until just before the
table is closed.  It is still possible to insert additional rows into a
binary table containing variable-length columns (with the ffirow
routine), however, the performance may be rather slow due to all the
internal shuffling of the data that must be performed.

When writing to a variable length field the entire array of values for
a given row of the table must be written with a single call to
ffpcl\_.  The total length of the array is given by nelements +
firstelem - 1.  Additional elements cannot be appended to an existing
vector at a later time since any attempt to do so will simply overwrite
all the previously written data.  Note also that the new data will be
written to a new area of the heap and the heap space used by the
previous write cannot be reclaimed.  For this reason each row of a
variable length field should only be written once.  An exception to
this general rule occurs when setting elements of an array as
undefined.  One must first write a dummy value into the array with
ffpcl\_, and then call ffpclu to flag the desired elements as
undefined.  (Do not use the ffpcn\_ family of routines with variable
length fields). Note that the rows of a table may be written in any
order.

When writing to a variable length ASCII character field (e.g., TFORM =
'1PA') only a single character string can be written.  The
`firstelem' and `nelements' parameter values in the ffpcls routine are
ignored and the number of characters to write is simply determined by
the length of the input null-terminated character string.

The ffpdes routine is useful in situations where multiple rows of a
variable length column have the identical array of values.  One can
simply write the array once for the first row, and then use ffpdes to
write the same descriptor values into the other rows;  all the rows
will then point to the same storage location thus saving disk space.

When reading from a variable length array field one can only read as
many elements as actually exist in that row of the table; reading does
not automatically continue with the next row of the table as occurs
when reading an ordinary fixed length table field.  Attempts to read
more than this will cause an error status to be returned.  One can
determine the number of elements in each row of a variable column with
the ffgdes routine.


\section{Support for IEEE Special Values}

The ANSI/IEEE-754 floating-point number standard defines certain
special values that are used to represent such quantities as
Not-a-Number (NaN), denormalized, underflow, overflow, and infinity.
(See the Appendix in the NOST FITS standard or the NOST FITS User's
Guide for a list of these values).  The CFITSIO routines that read
floating point data in FITS files recognize these IEEE special values
and by default interpret the overflow and infinity values as being
equivalent to a NaN, and convert the underflow and denormalized values
into zeros.  In some cases programmers may want access to the raw IEEE
values, without any modification by CFITSIO.  This can be done by
calling the ffgpv\_ or ffgcv\_ routines while specifying 0.0 as the
value of the NULLVAL parameter.  This will force CFITSIO to simply pass
the IEEE values through to the application program without any
modification.  This is not fully supported on VAX/VMS machines,
however, where there is no easy way to bypass the default
interpretation of the IEEE special values.


\section{Local FITS Conventions supported by CFITSIO}

In a couple cases CFITSIO supports local FITS conventions which are not
defined in the official NOST FITS standard and which are not
necessarily recognized or supported by other FITS software packages.
Programmers should be cautious about using these features, especially
if the FITS files that are produced are expected to be processed by
other software systems which do not use the CFITSIO interface.  These
local conventions should be considered as prototypes, and they may not
necessarily be supported in future versions of CFITSIO, especially if
an alternative convention is officially adopted by the FITS community.


\subsection{Long String Keyword Values.}

The length of a standard FITS string keyword is limited to 68
characters because it must fit entirely within a single FITS header
keyword record.  In some instances it is necessary to encode strings
longer than this limit, so CFITSIO supports a local convention in which
the string value is continued over multiple keywords.  This
continuation convention uses a ampersand character at the end of each
substring to indicate that it is continued on the next keyword, and the
continuation keywords all have the name CONTINUE without an equal sign
in column 9. The string value may be continued in this way over as many
additional CONTINUE keywords as is required.  The following lines
illustrate this continuation convention which is used in the value of
the STRKEY keyword:

\begin{verbatim}
LONGSTRN= 'OGIP 1.0'    / The OGIP Long String Convention may be used.
STRKEY  = 'This is a very long string keyword&'  / Optional Comment
CONTINUE  ' value that is continued over 3 keywords in the &  '
CONTINUE  'FITS header.' / This is another optional comment.
\end{verbatim}
It is recommended that the LONGSTRN keyword, as shown here, always be
included in any HDU that uses this longstring convention as a warning
to any software that must read the keywords.  A routine called ffplsw
has been provided in CFITSIO to write this keyword if it does not
already exist.

This long string convention is supported by the following CFITSIO
routines:

\begin{verbatim}
      ffpkls - write an arbitrarily long string keyword value
      ffgkls - read  an arbitrarily long string keyword value
      ffdkey - delete a keyword
\end{verbatim}
The ffgkls routine is unique among all the CFITSIO routines in that it
internally allocates memory for the long string value;  all the other
CFITSIO routines that deal with strings require that the calling
program pre-allocate adequate space to hold the array of characters.
Consequently, programs which use the ffgkls routine must be careful to
free the allocated memory for the string when it is no longer needed.

The following 2 routines also have limited support for this
long string convention,

\begin{verbatim}
      ffmkys - modify an existing string keyword value
      ffukys - update a string keyword value
\end{verbatim}
in that they will correctly overwrite an existing long string value,
but the new string value is limited to a maximum of 68 characters in
length.

The more commonly used CFITSIO routine to write string valued
keywords (ffpkys) does NOT support this long string convention and only
supports strings up to 68 characters in length.  This has been done
deliberately to prevent programs from inadvertently writing keywords
using this non-standard convention without the explicit intent of the
programmer or user.   The ffpkls routine must be called instead to
write long strings.  This routine can also be used to write ordinary
string values less than 68 characters in length.


\subsection{Arrays of Strings in Binary Table Extensions}

The definition of the FITS binary table extension format does not
provide a simple way to specify that a character column contains an
array of fixed-length strings.  To support this feature, CFITSIO uses a
local convention for the format of the TFORMn keyword value of the form
'rAw' where 'r' is an integer specifying the total width in characters
of the column, and 'w' is an integer specifying the (fixed) length of
an individual unit string within the vector.  For example, TFORM1 =
'120A10' would indicate that the binary table column is 120 characters
wide and consists of 12 10-character length strings.  This convention
is recognized by the CFITSIO routines that read or write strings in
binary tables.   The Binary Table definition document specifies that
other optional characters may follow the datatype code in the TFORM
keyword, so this local convention is in compliance with the
FITS standard although other FITS readers may not
recognize this convention.

The Binary Table definition document that was approved by the IAU in
1994 contains an appendix describing an alternate convention for
specifying arrays of fixed or variable length strings in a binary table
character column (with the form 'rA:SSTRw/nnn)'.  This appendix was not
officially voted on by the IAU and hence is still provisional.  CFITSIO
does not currently support this proposal.


\chapter{ Programming Guidelines }

The CFITSIO Cookbook (available in the file cookbook.c in the CFITSIO
software distribution directory) contains listings of various
routines that read and write CFITSIO files.  New users of CFITSIO should
study these examples to help learn how to most efficiently use the
CFITSIO library.   The following sections briefly summarize the
main steps in reading or writing a FITS file.


\section{Reading an existing FITS file}

The following sequence of routine calls illustrate a simple example
of reading an existing FITS file.

\begin{verbatim}
 1. Open the file with fits_open_file / ffopen.
 2. Read any desired header keywords with fits_read_key / ffgky.
 3. Read the primary data, if any, with fits_read_img / ffgpv.
 4. Repeat steps 2 and 3 until all the desired information has been read.
 5. Move to another extension with fits_movabs_hdu / ffmahd.
 6. Read any extension header keywords with fits_read_key / ffgky.
 7. Read any table column of data with fits_read_col / ffgcv.
 8. Repeat steps 6 and 7 until all the information has been read.
 9. Repeat steps 5 through 8 for any other extensions.
10. Close the file with fits_close_file / ffclos.
\end{verbatim}


\section{Creating a new FITS file}

The following sequence of routine calls illustrate a simple example
of writing a new FITS file:

\begin{verbatim}
 1. Create the new file with fits_create_file / ffinit.
 2. Write the required primary keywords with fits_create_img / ffcrim.
 3. Write any additional keywords with fits_write_key / ffpky.
 4. Write the primary array data, if any, with fits_write_img / ffppr.
 5. Create another extension, if desired, with fits_create_img / ffcrim
    or fits_create_tbl / ffcrtb.
 6. Write any additional keywords with fits_write_key / ffpky.
 7. Write data to table columns with fits_write_col /ffpcl.
 8. Repeat steps 5 - 7 for any more extensions.
 9. Close the fits file with fits_close_file / ffclos.
\end{verbatim}
Note that the application program must not explicitly write the
required 'END' keyword at the end of each header;  the CFITSIO interface
will automatically append the END record whenever the header is closed.
As a standard practice, users should always read back any FITS files
that they have created to ensure that the header values and data structure
are correct and self-consistent.


\section{When the Final Size of the FITS File is Unknown}

It is not required to know the total size of a FITS data array or table
before beginning to write the data to the FITS file.  In the case of
the primary array or an image extension, one should initially create
the array with the size of the highest dimension (largest NAXISn
keyword) set to a dummy value, such as 1.  Then after all the data have
been written and the true dimensions are known, then the NAXISn value
should be updated using the ffmkyj routine before moving to another
extension or closing the FITS file.

A similar procedure may be used in the case of FITS tables, where the
number of rows in the table (the NAXIS2 value) may initially be set to
1 and then updated with the correct value before closing the table.
Alternatively, one may use the ffirow routine to insert additional rows
into a table if the original value turns out to be too small.  This
latter method must be used if any of the columns contain variable
length arrays.


\section{Optimizing Code for Maximum Processing Speed}

CFITSIO has been carefully designed to obtain the highest possible
speed when reading and writing FITS files.  In order to achieve the
best performance, however, application programmers must be careful to
call the CFITSIO routines appropriately and in an efficient sequence;
inappropriate usage of CFITSIO routines can greatly slow down the
execution speed of a program.

The maximum possible I/O speed of CFITSIO depends of course on the type
of computer system that it is running on.  As a rough guide, the
current generation of workstations can achieve speeds of 2 -- 10 MB/s
when reading or writing FITS images and similar, or slightly slower
speeds with FITS binary tables.  Reading of FITS files can occur at
even higher rates (30MB/s or more) if the FITS file is still cached in
system memory following a previous read or write operation on the same
file.  To more accurately predict the best performance that is possible
on any particular system, a diagnostic program called ``speed.c'' is
included with the CFITSIO distribution which can be run to
approximately measure the maximum possible speed of writing and reading
a test FITS file.

The following 2 sections provide some background on how CFITSIO
internally manages the data I/O and describes some strategies that may
be used to optimize the processing speed of software that uses
CFITSIO.


\subsection{Background Information: How CFITSIO Manages Data I/O}

Many CFITSIO operations involve transfering only a small number of
bytes to or from the FITS file (e.g, reading a keyword, or writing a
row in a table); it would be very inefficient to physically read or
write such small blocks of data directly in the FITS file on disk,
therefore CFITSIO maintains a set of internal IO buffers in RAM memory
that each contain one FITS block (2880 bytes) of data.  Whenever
CFITSIO needs to access data in the FITS file, it first transfers the
FITS block containing those bytes into one of the IO buffers in
memory.  The next time CFITSIO needs to access bytes in the same block
it can then go to the fast IO buffer rather than using a much slower
system disk access routine.  The number of available IO buffers is
determined by the NIOBUF parameter (in fitsio2.h) and is currently set
to 25.

Whenever CFITSIO reads or writes data it first checks to see if that
block of the FITS file is already loaded into one of the IO buffers.
If not, and if there is an empty IO buffer available, then it will load
that block into the IO buffer (when reading a FITS file) or will
initialize a new block (when writing to a FITS file).  If all the IO
buffers are already full, it must decide which one to reuse (generally
the one that has been accessed least recently), and flush the contents
back to disk if it has been modified before loading the new block.

The one major exception to the above process occurs whenever a large
contiguous set of bytes are accessed, as might occur when reading or
writing a FITS image.  In this case CFITSIO bypasses the internal IO
buffers and simply reads or writes the desired bytes directly in the
disk file with a single call to a low-level file read or write
routine.  The minimum threshold for the number of bytes to read or
write this way is set by the MINDIRECT parameter and is currently set
to 3 FITS blocks = 8640 bytes.  This is the most efficient way to read
or write large chunks of data and can achieve IO transfer rates of
5 -- 10MB/s or greater.  Note that this fast direct IO process is not
applicable when accessing columns of data in a FITS table because the
bytes are generally not contiguous since they are interleaved by the
other columns of data in the table.  This explains why the speed for
accessing FITS tables is generally slower than accessing
FITS images.

Given this background information, the general strategy for efficiently
accessing FITS files should now be apparent:  when dealing with FITS
images, read or write large chunks of data at a time so that the direct
IO mechanism will be envoked;  when accessing FITS headers or FITS
tables, on the other hand, once a particular FITS block has been
loading into one of the IO buffers, try to access all the needed
information in that block before it gets flushed out of the IO buffer.
It is important to avoid the situation where the same FITS block is
being read then flushed from a IO buffer multiple time.

The following section gives more specific suggestions for optimizing
the use of CFITSIO.


\subsection{Optimization Strategies}

1.  When dealing with a FITS primary array or IMAGE extension, it is
more efficient to read or write large chunks of the  image at a time
(at least 3 FITS blocks = 8640 bytes) so that the direct IO mechanism
will be used as described in the previous section.  Smaller chunks of
data are read or written via the IO buffers, which is somewhat less
efficient because of the extra copy operation and additional
bookkeeping steps that are required.  In principle it is more efficient
to read or write as big an array of image pixels at one time as
possible, however, if the array becomes so large that the operating
system cannot store it all in RAM, then the performance may be degraded
because of the increased swapping of virtual memory to disk.

2.  When dealing with FITS tables, the most important efficiency factor
in the software design is to read or write the data in the FITS file in
a single pass through the file.  An example of poor program design
would be to read a large, 3-column table by sequentially reading the
entire first column, then going back to read the 2nd column, and
finally the 3rd column; this obviously requires 3 passes through the
file which could triple the execution time of an IO limited program.
For small tables this is not important, but when reading multi-megabyte
sized tables these inefficiencies can become significant.  The more
efficient procedure in this case is to read or write only as many rows
of the table as will fit into the available internal IO buffers, then
access all the necessary columns of data within that range of rows.
Then after the program is completely finished with the data in those
rows it can move on to the next range of rows that will fit in the
buffers, continuing in this way until the entire file has been
processed.  By using this procedure of accessing all the columns of a
table in parallel rather than sequentially, each block of the FITS file
will only be read or written once.

The optimal number of rows to read or write at one time in a given
table depends on the width of the table row, on the number of IO
buffers that have been allocated in CFITSIO, and also on the number of
other FITS files that are open at the same time (since one IO buffer is
always reserved for each open FITS file).  Fortunately, a CFITSIO
routine is available that will return the optimal number of rows for a
given table:  fits\_get\_rowsize(fitsfile *fptr, long *nrows, int *status).
It is not critical to use exactly the value of nrows
returned by this routine, as long as one does not exceed it.  Using a
very small value however can also lead to poor preformance because of
the overhead from the larger number of subroutine calls.

The optimal number of rows returned by fits\_get\_rowsize is valid only
as long as the application program is only reading or writing data in
the specified table.  Any other calls to access data in the table
header or in any other FITS file would  cause additional blocks of data
to be loaded into the IO buffers displacing data from the original
table, and should be avoided during the critical period while the table
is being read or written.

Occasionally it is necessary to simultaneously access more than one
FITS table, for example when transfering values from an input table to
an output table.  In cases like this, one should call
fits\_get\_rowsize to get the optimal number of rows for each table
separately, than reduce the number of rows proportionally.  For
example, if the optimal number of rows in the input table is 3600 and
is 1400 in the output table, then these values should be cut in half to
1800 and 700, respectively, if both tables are going to be accessed at
the same time.

3.  Alway use binary table extensions rather than ASCII table
extensions for better efficiency  when dealing with tabular data.  The
I/O to ASCII tables is slower because of the overhead in formatting or
parsing the ASCII data fields, and because ASCII tables are about twice
as large as binary tables with the same information content.

4. Design software so that it reads the FITS header keywords in the
same order in which they occur in the file.  When reading keywords,
CFITSIO searches forward starting from the position of the last keyword
that was read.  If it reaches the end of the header without finding the
keyword, it then goes back to the start of the header and continues the
search down to the position where it started.  In practice, as long as
the entire FITS header can fit at one time in the available internal IO
buffers, then the header keyword access will be very fast and it makes
little difference which order they are accessed.

5. Avoid the use of scaling (by using the BSCALE and BZERO or TSCAL and
TZERO keywords) in FITS files since the scaling operations add to the
processing time needed to read or write the data.  In some cases it may
be more efficient to temporarily turn off the scaling (using ffpscl or
fftscl) and then read or write the raw unscaled values in the FITS
file.

6. Avoid using the 'implicit datatype conversion' capability in
CFITSIO.  For instance, when reading a FITS image with BITPIX = -32
(32-bit floating point pixels), read the data into a single precision
floating point data array in the program.  Forcing CFITSIO to convert
the data to a different datatype can significantly slow the program.

7. Design FITS binary tables so that every column is aligned on a
computer word boundary and each row is a multiple number of computer
words in length.  In principle, accessing non-aligned words can degrade
performance.   This is usually not a problem when using CFITSIO to read
or write the FITS files, but other FITS readers and writers could be
affected. In an optimally designed table,  double precision columns
should start at a multiple of 8 bytes within the row, single precision
floating point columns and long integer columns should start at a
multiple of 4 bytes, and short integer columns should start at a
multiple of 2 bytes.  If necessary, the row length should be padded out
by adding a dummy column of the appropriate width or by adjusting the
width of an existing column so that the row length is also a multiple
number of 8 bytes in length.  For example, if a binary table contains a
'1B', a '1E', and a '1D' column, then the optimum design would place
the '1D' column first in the table followed by the '1E' and then the
'1B' column.  Since the row length is then 8 + 4 + 1 = 13 bytes, one
should add another dummy column, with a 3A datatype to make the length
a multiple of the double precision word length.  Alternatively, one
could change the last column from '1B' to '4B'. This will insure that
all the data values are optimally aligned.

8. Where feasible, design FITS binary tables using vector column
elements so that the data are written as a contiguous set of bytes,
rather than as single elements in multiple rows.  For example, it is
much faster to access the data in a table that contains a single row
and 2 columns with TFORM keywords equal to  '10000E' and '10000J', than
it is to access the same amount of data in a table with 10000 rows
which has columns with the TFORM keywords equal to '1E' and '1J'.  In
the former case the 10000 floating point values in the first column are
all written in a contiguous block of the file which can be read or
written quickly, whereas in the second case each floating point value
in the first column is interleaved with the integer value in the second
column of the same row so CFITSIO has to explicitly move to the
position of each element to be read or written.

9. Avoid the use of variable length vector columns in binary tables,
since any reading or writing of these data requires that CFITSIO first
look up or compute the starting address of each row of data in the
heap.

10. When copying data from one FITS table to another, it is faster to
transfer the raw bytes instead of reading then writing each column of
the table.  The CFITSIO routines ffgtbb and ffptbb will perform
low-level reads or writes of any contiguous range of bytes in a table
extension.  These routines can be used to read or write a whole row (or
multiple rows  for even greater efficiency) of a table with a single
function call.   These routines are fast because they bypass all the
usual data scaling, error checking and machine dependent data
conversion that is normally done by CFITSIO, and they allow the program
to write the data to the output file in exactly the same byte order.
For these same reasons, use of these routines can be somewhat risky
because no validation or machine dependent conversion is performed by
these routines.  In general these routines are only recommended for
optimizing critical pieces of code and should only be used by
programmers who thoroughly understand the internal format of the FITS
tables they are reading or writing.

10. Another strategy for improving the speed of writing a FITS table,
similar to the previous one, is to directly construct the entire byte
stream for a whole table row (or multiple rows) within the application
program and then write it to the FITS file with ffptbb.  This avoids
all the overhead normally present in the column-oriented CFITSIO write
routines.  This technique should only be used for critical
applications, because it makes the code more difficult to understand
and maintain, and it makes the code more system dependent (e.g., do the
bytes need to be swapped before writing to the FITS file?).

11.  Finally, external factors such as the type of magnetic disk
controller (SCSI or IDE), the size of the disk cache, the average seek
speed of the disk, the amount of disk fragmentation, and the amount of
RAM available on the system can all have a significant impact on
overall IO efficiency.  For critical applications, a system
adminstrator should review the proposed system hardware to identify any
potential IO bottlenecks.


\section{CFITSIO Size Limitations}

In general, CFITSIO places no limits on the sizes of the FITS files that
it reads or writes. In particular there is no internal limit on the size of the
dimensions of the primary array or IMAGE extension. Tables extensions may have
up to 999 columns (the maximum allowed by the FITS standard) and
may have an arbitrarily large number of rows. There are a few other limits,
however, which may affect some extreme cases:

1.  The maximum number of files that may be simultaneously opened is limited
to the number of internal IO buffers allocated in CFITSIO (currently 25),
or by the limit of the underlying C compiler or machine operating system, which
ever is smaller.
The C symbolic constant FOPEN\_MAX usually defines the total number of
files that may open at once (this includes any other text or binary
files which may be open, not just FITS files).

2.  The maximum number of extensions that can be read or written in a
single FITS file is current set to 1000 as defined by MAXHDU in the
fitsio.h file.  This value may be increased if necessary, but the
access times to the later extensions in such files may become very
long.

3.  CFITSIO can handle FITS files up to about 2.1 GB in size which is
the maximum value of a 4-byte signed long integer.  Some machines that use
8-byte words for a long integer may support larger files, but this has
not been tested.

\chapter{ Basic Interface Routines }

This section defines a basic set of routines that can be
used to perform the most common types of read and write operations
on FITS files.  New users should start with these routines and
then, as needed, explore the more advance routines described in
the following chapter to perform more complex or specialized operations.

Each routine has 2 names: a long descriptive
name and a short concise name.  Both names are listed on the first
line of the following descriptions, separated by a slash (/) character.
It makes no difference which name is used in the source code.

A right arrow symbol ($>$) is used to separate the input parameters from
the output parameters in the  definition of each routine.  This symbol
is not actually part of the C calling sequence.  Note that
the status parameter is both an input and an output parameter
and must be initialized = 0 prior to calling the CFITSIO routines.

Refer to Chapter 9 for the definition of all the parameters
used by these interface routines.


\section{File I/O Routines}

CFITSIO uses a C structure (as defined in fitsio.h) to store all the
relevant parameters about the format of an opened FITS file.
Application programs must first declare a pointer to this structure
(which is named 'fitsfile') for each FITS file that is opened.  The
value of the pointer is defined by the call to open or create the FITS
file and then the pointer must be passed as the first argument to all
the other CFITSIO routines that read or write the FITS file.  The
memory that is allocated for the fitsfile structure is freed when
the FITS file is closed.  Application programs must not directly
read or write information in this fitsfile structure because
the definition of the structure may change in future versions of
CFITSIO.


\begin{description}
\item[1 ] Open an existing FITS file with readonly or readwrite access.
    The iomode parameter has allowed symbolic constant values of
   READONLY or READWRITE.
\end{description}

\begin{verbatim}
  int fits_open_file / ffopen
      (fitsfile **fptr, const char *filename, int iomode, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Open and initialize a new empty FITS file
\end{description}

\begin{verbatim}
  int fits_create_file / ffinit
      (fitsfile **fptr, const char *filename, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Close a previously opened FITS file.
\end{description}

\begin{verbatim}
  int fits_close_file / ffclos
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Move to a specified (absolute) HDU in the FITS file.  When a FITS file
    is first opened or created it is automatically positioned to the first
   HDU (the primary array) in the file which has hdunum = 1.
\end{description}

\begin{verbatim}
  int fits_movabs_hdu / ffmahd
      (fitsfile *fptr, int hdunum, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[5 ]Create a new primary array if a new empty FITS file has just been
   created, otherwise append a new IMAGE extension following the current HDU.
  Refer to Chapter 9 for a list of the pre-defined bitpix values.
\end{description}

\begin{verbatim}
  int fits_create_img / ffcrim
      ( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[6 ]Create (append) a new table extension following the current HDU.
   The type of table is specified by the tbltype parameter which can have
   symbolic constant values of ASCII\_TBL or BINARY\_TBL.  See Chapter 9
  for a list of the allowed values for the tform parameter.
\end{description}

\begin{verbatim}
  int fits_create_tbl / ffcrtb
      (fitsfile *fptr, int tbltype, long naxis2, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, int *status)
\end{verbatim}


\section{Keyword I/O Routines}


\begin{description}
\item[1 ]Write an 80-character keyword record into the current header.  The
   record will be padded with blanks if the input null-terminated
  card string is less than 80 characters long.
\end{description}

\begin{verbatim}
  int fits_write_record / ffprec
      (fitsfile *fptr, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Write a new keyword with the specified datatype into the current header.
    The datatype parameter can have one of the following symbolic constant
    values: TSTRING, TLOGICAL, TBYTE, TUSHORT, TSHORT, TINT, TULONG, TLONG,
    TFLOAT, TDOUBLE.  Note that the address of the value, not the value
   itself, must be supplied to this routine.
\end{description}

\begin{verbatim}
  int fits_write_key / ffpky
      (fitsfile *fptr, int datatype, char *keyname, DTYPE *value,
       char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Read the nth 80-character header record from the current header.
   The first keyword in the header is at keynum = 1.
\end{description}

\begin{verbatim}
  int fits_read_record / ffgrec
      (fitsfile *fptr, int keynum, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Read a keyword value and comment from the current header.  The
    allowed values for the `datatype' parameter are listed above.
    Automatic datatype conversion will be attempted if
   `datatype' is not the same as the actual datatype of the keyword.
    If a NULL comment pointer is given on input, then the comment string
   will not be returned.
\end{description}

\begin{verbatim}
  int fits_read_key / ffgky
      (fitsfile *fptr, int datatype, char *keyname, > DTYPE *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[5 ] Delete a specified keyword record.
\end{description}

\begin{verbatim}
  int fits_delete_key / ffdkey
      (fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}


\section{Data I/O Routines}

The following routines read or write data values in the current HDU of
the FITS file. The `datatype' parameter specifies the datatype of the
`array` of values and the `nulval' parameter can have one of the
following symbolic constant values: TBYTE, TUSHORT, TSHORT, TINT,
TULONG, TLONG, TFLOAT, or TDOUBLE.  The routines for reading or writing
table columns also support the TBIT, TLOGICAL, TSTRING, TCOMPLEX and
TDBLCOMPLEX datatypes. Automatic datatype conversion will be attempted
for numerical datatypes if the specified datatype is different from the
actual datatype of the FITS array or table column.


\begin{description}
\item[1 ] Write elements into the primary array or image extension.
\end{description}

\begin{verbatim}
  int fits_write_img / ffppr
      (fitsfile *fptr, int datatype, long firstelem, long nelements,
       DTYPE *array, int *status);
\end{verbatim}

\begin{description}
\item[2 ] Read elements from the primary array or image extension.
    Undefined array elements will be returned with a value = *nulval
    unless nulval = 0 or *nulval = 0, in which case no checks
    for undefined pixels will be performed. The anynul parameter is
    set to true (= 1) if any of the returned
    elements were undefined. Note that the {\em address} to the
   null value, not the null value itself must be supplied to this routine.
\end{description}

\begin{verbatim}
  int fits_read_img / ffgpv
      (fitsfile *fptr, int  datatype, long firstelem, long nelements,
       DTYPE *nulval, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Write elements into an ASCII or binary table column.  The `firstelem'
    parameter applies only to vector columns in binary tables and is
   ignored when writing to ASCII tables.
\end{description}

\begin{verbatim}
  int fits_write_col / ffpcl
      (fitsfile *fptr, int datatype, int colnum, long firstrow,
       long firstelem, long nelements, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Read elements from an ASCII or binary table column.  Undefined
    array elements will be returned with a value = *nulval unless nulval = 0
    or *nulval = 0, in which case no checking for undefined values will be
    performed. The anynul parameter is set to true (= 1) if any of the returned
    elements were undefined.  Note that the {\em address} to the
   null value, not the null value itself must be supplied to this routine.
\end{description}

\begin{verbatim}
  int fits_read_col / ffgcv
      (fitsfile *fptr, int datatype, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE *nulval, DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[5 ] Get the table column number and full name of the column whose name
    matches the input template string.  See the `Advanced Interface Routines'
   chapter for a full description of this routine.
\end{description}

\begin{verbatim}
  int fits_get_colname / ffgcnn
      (fitsfile *fptr, int casesen, char *templt, > char *colname,
       int *colnum, int *status)
\end{verbatim}

\chapter{   Advanced Interface Routines }

This chapter defines all the available routines in the CFITSIO user
interface.  For completeness, the basic routines
described in the previous chapter are also repeated here.
Refer to Chapter 9 for the definition of all the parameters.

The following conventions are used in this chapter:

1. Each routine has 2 names: a long descriptive
name and a short concise name.  Both names are listed on the first
line of the following descriptions, separated by a slash (/) character.

2. A right arrow symbol ($>$) is used to separate the input parameters from
the output parameters in the  definition of each routine.  This symbol
is not actually part of the C calling sequence.  Note that
the status parameter is both an input and an output parameter.

3. Families of similar routines which differ only in the datatype
of the argument(s) are defined together using a convention
of listing the last letter(s) of the routine names in square brackets.
For example, the routines for reading data from a primary array
are defined as:

\begin{verbatim}
  int ffgpv[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE nulval, > DTYPE *array, int *anynul,
           int *status)
\end{verbatim}
This is a short-hand notation for indicating that there are 8 separate
routines, ffgpvb, ffgpvi, ffgpvui, ffgpvj, ffgpvuj, ffgpvk, ffgpve, and
ffgpvd, which have different datatypes for the nulval and array
arguments.

4. A datatype specification of `DTYPE' is used to indicate
that the parameter has a numerical datatype which depends on the last
letter(s) of the routine's short name as given by the following table:

\begin{verbatim}
      Name     Data
      suffix   type
      ----     --------
        b   -  unsigned char
        l   -  int (logical value)
        i   -  short integer
        j   -  long integer
       ui   -  unsigned short integer
       uj   -  unsigned long integer
        k   -  int integer
     e, f   -  float
     d, g   -  double
        c   -  pairs of floats (complex value)
        m   -  pairs of doubles (complex value)
\end{verbatim}
Thus, in the previous example the `nulval' and `array'  parameters have
a short int datatype in the ffgpvi routine and have a
double datatype in the ffgpvd routine.


\section{FITS File Open and Close Routines \label{FFOPEN}}

CFITSIO uses a C structure (as defined in fitsio.h) to store all the
relevant parameters about the format of an opened FITS file.
Application programs must first declare a pointer to this structure
(which is named 'fitsfile') for each FITS file that is opened.  The
value of the pointer is defined by the call to open or create the FITS
file and then the pointer must be passed as the first argument to all
the other CFITSIO routines that read or write the FITS file.  The
memory that is allocated for the fitsfile structure is freed when
the FITS file is closed.


\begin{description}
\item[1 ] Open an existing FITS file with readonly or readwrite access.
    The iomode parameter has allowed symbolic constant values of
   READONLY or READWRITE.
\end{description}

\begin{verbatim}
  int fits_open_file / ffopen
      (fitsfile **fptr, char *filename, int iomode, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Open and initialize a new empty FITS file
\end{description}

\begin{verbatim}
  int fits_create_file / ffinit
      (fitsfile **fptr, char *filename, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Flush any internal buffers of data to the output FITS file. This
   routine usually never needs to be called, but doing so will ensure
   that if the program subsequently aborts then the FITS file will
  have been closed properly.
\end{description}

\begin{verbatim}
  int fits_flush_file / ffflus
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[4 ]Close a previously opened FITS file.
\end{description}

\begin{verbatim}
  int fits_close_file / ffclos
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Close and DELETE a FITS file previously opened with ffopen or ffinit.
    This routine may be  useful in cases where a FITS file is created but
   then an error occurs which prevents the file from being completed.
\end{description}

\begin{verbatim}
  int fits_delete_file / ffdelt
      (fitsfile *fptr, > int *status)
\end{verbatim}


\section{HDU-Level Operations\label{FFMAHD}}

The following routines perform operations on entire HDUs: move, create,
insert, copy, and delete HDUs.


\begin{description}
\item[1 ] Move to a specified (absolute) HDU in the FITS file.  When a FITS file
    is first opened or created it is automatically positioned to the first
   HDU (the primary array) in the file which has hdunum = 1.
\end{description}

\begin{verbatim}
  int fits_movabs_hdu / ffmahd
      (fitsfile *fptr, int hdunum, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[2 ]Move a relative number of HDUs forward or backwards in the FITS file.
\end{description}

\begin{verbatim}
  int fits_movrel_hdu / ffmrhd
      (fitsfile *fptr, int nmove, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get the number of the current HDU in the FITS file (primary array = 1).
   This routine returns the HDU number rather than a status value.
\end{description}

\begin{verbatim}
  int fits_get_hdunum / ffghdn
      (fitsfile *fptr, > int *hdunum)
\end{verbatim}

\begin{description}
\item[5 ]Create a new primary array if a new empty FITS file has just been
   created, otherwise append a new IMAGE extension following the current HDU.
   Refer to Chapter 9 for a list of pre-defined bitpix values.
  This routine simply combines calls to ffcrhd and ffphps.
\end{description}

\begin{verbatim}
  int fits_create_img / ffcrim
      ( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[5 ]Create (append) a new table extension following the current HDU.
   This routine simply combines calls to ffcrhd and ffphtb or ffphbn.
   The type of table is specified by the tbltype parameter which can have
   symbolic constant values of ASCII\_TBL or BINARY\_TBL.  See Chapter 9
  for a list of allowed tform values.
\end{description}

\begin{verbatim}
  int fits_create_tbl / ffcrtb
      (fitsfile *fptr, int tbltype, long naxis2, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, int *status)
\end{verbatim}

\begin{description}
\item[6 ]Create (append) a new empty HDU following the last extension that
    has been previously accessed by the program.   This will overwrite
    any later extensions that may exist in the FITS file but which
    have not been accessed.
    For example, if an existing FITS file contains a primary array plus 5
    extensions and a program (1) opens the FITS file, (2) moves to
    extension 4, (3) moves back to the primary array, and (4) then calls
    ffcrhd, then the new extension will be written following the 4th
   extension, overwriting the existing 5th extension.
\end{description}

\begin{verbatim}
  int fits_create_hdu / ffcrhd
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Insert a new IMAGE extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new image extension will simply be appended to the
    end of the file.  The new extension will become the CHDU.
   Refer to Chapter 9 for a list of pre-defined bitpix values.
\end{description}

\begin{verbatim}
  int fits_insert_img / ffiimg
      (fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[8 ] Insert a new ASCII TABLE extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new table extension will simply be appended to the
    end of the file.  The new extension will become the CHDU.
   See Chapter 9  for a list of allowed tform values.
\end{description}

\begin{verbatim}
  int fits_insert_atbl / ffitab
      (fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
       long *tbcol, char **tform, char **tunit, char *extname, > int *status)
\end{verbatim}

\begin{description}
\item[9 ] Insert a new binary table extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new bintable extension will simply be appended to the
    end of the file.  If there are following extensions and if
    the table contains variable length array columns
    then pcount must specify the expected final size of the data heap,
    otherwise pcount must = 0.  The new extension will become the CHDU.
   See Chapter 9  for a list of allowed tform values.
\end{description}

\begin{verbatim}
  int fits_insert_btbl / ffibin
      (fitsfile *fptr, long nrows, int tfields, char **ttype,
      char **tform, char **tunit, char *extname, long pcount, > int *status)
\end{verbatim}

\begin{description}
\item[10] Delete the CHDU in the FITS file.  Any following HDUs will be shifted
    forward in the file, to fill in the gap created by the deleted HDU.
    This routine will only delete extensions; the primary array (the first
    HDU in the file) cannot be deleted.  The physical size of the FITS file
    will not change and the end of the file will be padded out with
    zeros to fill in the space left after the CHDU is deleted. If
    there are more extensions in the file following the one that is deleted,
    then the the CHDU will be defined to point to the following extension.
    If there are no following extensions then the CHDU will be redefined
    to point to the previous HDU.  The output HDUTYPE parameter
    indicates the type of the new CHDU after the previous CHDU has been
   deleted.
\end{description}

\begin{verbatim}
  int fits_delete_hdu / ffdhdu
      (fitsfile *fptr, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[11] Copy the entire CHDU from the FITS file associated with infptr to the CHDU
    of the FITS file associated with outfptr. The output HDU must be empty
    and not already contain any keywords.  Space will be reserved for MOREKEYS
    additional  keywords in the output header if there is not already enough
   space.
\end{description}

\begin{verbatim}
  int fits_copy_hdu / ffcopy
      (fitsfile *infptr, fitsfile *outfptr, int morekeys, > int *status)
\end{verbatim}

\begin{description}
\item[12] Copy the data (and not the header) from the CHDU associated with infptr
    to the CHDU associated with outfptr. This will overwrite
    any data previously in the output CHDU.  This low level routine is used
    by ffcopy, but it may also be useful in certain application programs
    which want to copy the data from one FITS file to another but also
    want to modify the header keywords. The required FITS header keywords
    which define the structure of the HDU must be written to the
   output CHDU before calling this routine.
\end{description}

\begin{verbatim}
  int fits_copy_data / ffcpdt
      (fitsfile *infptr, fitsfile *outfptr, > int *status)
\end{verbatim}

\begin{description}
\item[13] This routine forces CFITSIO to scan the current header keywords that
    define the structure of the HDU (such as the NAXISn, PCOUNT and GCOUNT
    keywords) so that it can initialize the internal buffers that describe
    the HDU structure.  This routine is
    useful for reinitializing the structure of an HDU, e.g.,
    if the number of rows in a table, as specified by the NAXIS2 keyword,
    has been modified from its initial value.  In practice it should
    rarely be necessary to call this routine because CFITSIO
   internally calls it in most situations.
\end{description}

\begin{verbatim}
  int fits_set_hdustruc / ffrdef
      (fitsfile *fptr, > int *status)   (DEPRECATED)
\end{verbatim}


\section{FITS Header I/O Routines}


\subsection{ Header Space and Position Routines \label{FFHDEF}}


\begin{description}
\item[1 ] Reserve space in the CHU for MOREKEYS more header keywords.
    This routine may be called to reserve space for keywords which are
    to be written at a later time, after the data unit or subsequent
    extensions have been written to the FITS file.  If this routine is
    not explicitly called then the initial size of the FITS header will be
    limited to the space available at the time that  the first data is written
    to the associated data unit.   CFITSIO will dynamically
    add more space to the header if needed, however it is more efficient
   to preallocate the required space if the size is known in advance.
\end{description}

\begin{verbatim}
  int fits_set_hdrsize / ffhdef
      (fitsfile *fptr, int morekeys, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Return the number of existing keywords in the CHU (NOT counting the
    END keyword which is not considered a real keyword) and the remaining
    space available to write additional keywords in the CHU (returns
    morekeys = -1 if the header has not yet been closed).
    Note that CFITSIO will attempt to dynamically add space for more
   keywords if required when appending new keywords to a header.
\end{description}

\begin{verbatim}
  int fits_get_hdrspace / ffghsp
      (fitsfile *fptr, > int *keysexist, int *morekeys, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Return the number of keywords in the header (not counting the END
    keyword) and the current position
    in the header.  The position is the number of the keyword record that
    will be read next (or one greater than the position of the last keyword
    that was read or written). A value of 1 is returned if the pointer is
   positioned at the beginning of the header.
\end{description}

\begin{verbatim}
  int fits_get_hdrpos / ffghps
      (fitsfile *fptr, > int *keysexist, int *keynum, int *status)
\end{verbatim}

\subsection{ Read or Write Standard Header Routines \label{FFPHPS}}

These routines provide a simple method of reading or writing most of
the keyword values that are normally required in a FITS files.  These
routines are provided for convenience and are not required to
be used.  If preferred, users may call the lower-level routines
described in the previous section to individually read or write the
required keywords.  Note that in most cases the required keywords such
as NAXIS, TFIELD, TTYPEn, etc, which define the structure of the HDU
must be written to the header before any data can be written to the
image or table.



\begin{description}
\item[1 ] Put the primary header or IMAGE extension keywords into the CHU.
  The simpler ffphps routine is equivalent to calling ffphpr with the
  default values of simple = TRUE, pcount = 0, gcount = 1, and extend =
  TRUE.  The PCOUNT, GCOUNT and EXTEND keywords are not required in the
  primary header and are only written if pcount is not equal to zero,
  gcount is not equal to zero or one, and if extend is TRUE,
  respectively.  When writing to an IMAGE extension, the SIMPLE and
  EXTEND parameters are ignored. Refer to Chapter 9 for a list of
 pre-defined bitpix values.
\end{description}

\begin{verbatim}
  int fits_write_imghdr / ffphps
      (fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)

  int fits_write_grphdr / ffphpr
      (fitsfile *fptr, int simple, int bitpix, int naxis, long *naxes,
       long pcount, long gcount, int extend, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get primary header or IMAGE extension keywords from the CHU.  When
    reading from an IMAGE extension the SIMPLE and EXTEND parameters are
   ignored.
\end{description}

\begin{verbatim}
  int fits_read_imghdr / ffghpr
      (fitsfile *fptr, int maxdim, > int *simple, int *bitpix, int *naxis,
       long *naxes, long *pcount, long *gcount, int *extend, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Put the ASCII table header keywords into the CHU The optional
    TUNITn and EXTNAME keywords are written only if the input string
   values are not null. See Chapter 9  for a list of allowed tform values.
\end{description}


\begin{verbatim}
  int fits_write_atblhdr / ffphtb
      (fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
       long *tbcol, char **tform, char **tunit, char *extname, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get the ASCII table header keywords from the CHU
\end{description}

\begin{verbatim}
  int fits_read_atblhdr / ffghtb
      (fitsfile *fptr,int maxdim, > long *rowlen, long *nrows,
       int *tfields, char **ttype, long *tbcol, char **tform, char **tunit,
       char *extname,  int *status)
\end{verbatim}

\begin{description}
\item[5 ]Put the binary table header keywords into the CHU. The optional
   TUNITn and EXTNAME keywords are written only if the input string
   values are not null.  The pcount parameter, which specifies the
   size of the variable length array heap, should initially = 0;
   CFITSIO will automatically update the PCOUNT keyword value if any
   variable length array data is written to the heap.  The TFORM keyword
   value for variable length vector columns should have the form 'Pt(len)'
   or '1Pt(len)' where `t' is the data type code letter (A,I,J,E,D, etc.)
   and  `len' is an integer specifying the maximum length of the vectors
   in that column (len must be greater than or equal to the longest
   vector in the column).  If `len' is not specified when the table is
   created (e.g., the input TFORMn value is just '1Pt') then CFITSIO will
   scan the column when the table is first closed and will append the
   maximum length to the TFORM keyword value.  Note that if the table
   is subsequently modified to increase the maximum length of the vectors
   then the modifying program is responsible for also updating the TFORM
  keyword value.  See Chapter 9  for a list of allowed tform values.
\end{description}


\begin{verbatim}
  int fits_write_btblhdr / ffphbn
      (fitsfile *fptr, long nrows, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, long pcount, > int *status)
\end{verbatim}

\begin{description}
\item[6 ]Get the binary table header keywords from the CHU
\end{description}

\begin{verbatim}
  int fits_read_btblhdr / ffghbn
      (fitsfile *fptr, int maxdim, > long *nrows, int *tfields,
       char **ttype, char **tform, char **tunit, char *extname,
       long *pcount, int *status)
\end{verbatim}


\subsection{ Write Keyword Routines  \label{FFPREC}}


\begin{description}
\item[1 ]Put (append) an 80-character keyword record into the CHU.  The
   record will be padded with blanks if the input null-terminated
  card string is less than 80 characters long.
\end{description}

\begin{verbatim}
  int fits_write_record / ffprec
      (fitsfile *fptr, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Put (append) a COMMENT keyword into the CHU.  The comment string will
   be split over multiple COMMENT keywords if it is longer than 70 characters.
\end{description}

\begin{verbatim}
  int fits_write_comment / ffpcom
      (fitsfile *fptr, char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Put (append) a HISTORY keyword into the CHU.  The comment string will
  be split over multiple COMMENT keywords if it is longer than 70 characters.
\end{description}

\begin{verbatim}
  int fits_write_history / ffphis
      (fitsfile *fptr, char *history, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Put (append) the DATE keyword into the CHU.  The keyword value will contain
    the current system date as a character string in 'dd/mm/yy' format. If
    a DATE keyword already exists in the header, then this routine will
   simply update the keyword value with the current date.
\end{description}

\begin{verbatim}
  int fits_write_date / ffpdat
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Put (append) a new keyword of the appropriate datatype into the CHU.
    This is a generic routine in which
    the datatype parameter specifies the datatype of the keyword value
    with one of the following symbolic constant values:  TSTRING,
    TLOGICAL, TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG, TFLOAT, TDOUBLE.
    This routine then calls one of the datatype specific keyword writing
   routines described immediately below.
\end{description}

\begin{verbatim}
  int fits_write_key / ffpky
      (fitsfile *fptr, int datatype, char *keyname, DTYPE *value,
          char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put (append) a new keyword of the appropriate datatype into the CHU.
    There is a separate routine for each datatype.
    Note that ffpkys will only write string values up to 68 characters in
    length and longer strings will be truncated.  The ffpkls routine can be
    used to write longer strings, using the non-standard FITS convention
   that was described in an earlier section.
\end{description}

\begin{verbatim}
  int fits_write_key_str / ffpkys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_write_key_[log, lng] /  ffpky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_write_key_[flt, dbl, fixflg, fixdbl] / ffpky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Put (append) a string valued keyword into the CHU which may be longer
    than 68 characters in length.  This uses the Long String Keyword
    convention that is described in the "Local FITS Conventions"
    section of this document.  Since this uses a non-standard FITS
    convention to encode the long keyword string, programs which use
    this routine should also call the ffplsw routine to add some COMMENT
    keywords to warn users of the FITS file that this convention is
    being used.  The ffplsw routine also writes a keyword called LONGSTRN to
    record the version of the longstring convention that has been used, in
    case a new convention is adopted at some point in the future.   If the
    LONGSTRN keyword is already present in the header, then ffplsw will
   simply return and will not write duplicate keywords.
\end{description}

\begin{verbatim}
  int fits_write_key_longstr / ffpkls
      (fitsfile *fptr, char *keyname, char *longstr, char *comment,
       > int *status)

  int fits_write_key_longwarn / ffplsw
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[8 ] Put (append) a numbered sequence of keywords into the CHU.   One may
    append the same comment to every keyword (and eliminate the need
    to have an array of identical comment strings, one for each keyword) by
    including the ampersand character as the last non-blank character in the
    (first) COMMENTS string parameter.  This same string
   will then be used for the comment field in all the keywords.
\end{description}

\begin{verbatim}
  int fits_write_keys_str / ffpkns
      (fitsfile *fptr, char *keyroot, int nstart, int nkeys,
       char **value, char **comment, > int *status)

  int fits_write_keys_[log, lng] / ffpkn[lj]
      (fitsfile *fptr, char *keyroot, int nstart, int nkeys,
       DTYPE *numval, char **comment, int *status)

  int fits_write_keys_[flt, dbl, fixflg, fixdbl] / ffpkne[edfg]
      (fitsfile *fptr, char *keyroot, int nstart, int nkey,
       DTYPE *numval, int decimals, char **comment, > int *status)
\end{verbatim}

\begin{description}
\item[9 ] Put (append) a `triple precision' keyword into the CHU in F28.16 format.
    The floating point keyword value is constructed by concatenating the
    input integer value with the input double precision fraction value
    (which must have a value between 0.0 and 1.0). The ffgkyt routine should
    be used to read this keyword value, because the other keyword reading
   routines will not preserve the full precision of the value.
\end{description}

\begin{verbatim}
  int fits_write_key_triple / ffpkyt
      (fitsfile *fptr, char *keyname, long intval, double frac,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Insert Keyword Routines \label{FFIREC}}

These insert routines are somewhat less efficient than the `append' keyword
routines described above because the remaining keywords in the header must
be shifted down one position.


\begin{description}
\item[1 ] Insert a new keyword record into the CHU at the specified position
   (i.e., immediately preceding the (keynum)th keyword in the header.)
\end{description}

\begin{verbatim}
  int fits_insert_record / ffirec
      (fitsfile *fptr, int keynum, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Insert a new keyword into the CHU.  The new keyword is inserted
   immediately following the last keyword that has been read from the header.
\end{description}

\begin{verbatim}
  int fits_insert_key_str / ffikys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_insert_key_[log, lng] / ffiky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_insert_key_[flt, fixflt, dbl, fixdbl] / ffiky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Read Keyword Routines \label{FFGREC}}

These routines return the value of the specified keyword(s).  Wild card
characters (*, ?, or \#) may be used when specifying the name of the keyword
to be read: a '?' will match any single character at that position in the
keyword name and a '*' will match any length (including zero) string of
characters.  The '\#' character will match any consecutive string of
decimal digits (0 - 9). Note that when a wild card is used in the input
keyword name, the routine will only search for a match from the current
header position to the end of the header.  It will not resume the search
from the top of the header back to the original header position as is done
when no wildcards are included in the keyword name.  If the desired
keyword string is 8-characters long (the maximum length of a keyword
name) then a '*' may be appended as the ninth character of the input
name to force the keyword search to stop at the end of the header
(e.g., 'COMMENT *' will search for the next COMMENT keyword).  The
ffgrec routine may be used to set the starting position when doing
wild card searches.


\begin{description}
\item[1 ]Get the nth 80-character header record from the CHU.  The first keyword
   in the header is at keynum = 1;  if keynum = 0 then this routine
   simple moves the internal pointer to the beginning of the header
   so that subsequent keyword operations will start at the top of
  the header; it returns a null card value in this case.
\end{description}

\begin{verbatim}
  int fits_read_record / ffgrec
      (fitsfile *fptr, int keynum, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get the name, value (as a string), and comment of the nth keyword in CHU.
    This routine also checks that the returned keyword name (keyname) contains
    only legal ASCII characters. If a NULL comment pointer is given on input,
   then the comment string will not be returned.
\end{description}

\begin{verbatim}
  int fits_read_keyn / ffgkyn
      (fitsfile *fptr, int keynum, > char *keyname, char *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get the 80-character header record for the named keyword
\end{description}

\begin{verbatim}
  int fits_read_card / ffgcrd
      (fitsfile *fptr, char *keyname, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get the next keyword whose name matches one of the strings in
    'inclist' but does not match any of the strings in 'exclist'.
    The strings in inclist and exclist may contain wild card characters
    (*, ?, and \#) as described at the beginning of this section.
    This routine searches from the current header position to the
    end of the header, only, and does not continue the search from
    the top of the header back to the original position.  The current
    header position may be reset with the ffgrec routine.  Note
    that nexc may be set = 0 if there are no keywords to be excluded.
    This routine returns status = KEY\_NO\_EXIST (202) if a matching
   keyword is not found.
\end{description}

\begin{verbatim}
  int fits_find_nextkey / ffgnxk
      (fitsfile *fptr, char **inclist, int ninc, char **exclist,
       int nexc, > char *card, int  *status)
\end{verbatim}

\begin{description}
\item[5 ] Get the literal keyword value as a character string.  Regardless
    of the datatype of the keyword, this routine simply returns the
    string of characters in the value field of the keyword along with
    the comment field.   If a NULL comment pointer is given on input,
   then the comment string will not be returned.
\end{description}

\begin{verbatim}
  int fits_read_keyword / ffgkey
      (fitsfile *fptr, char *keyname, > char *value, char *comment,
       int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get a keyword value (with the appropriate datatype) and comment from the
    CHU. The datatype parameter specifies the datatype of the keyword value
    and can have one of the following symbolic constant values:  TSTRING,
    TLOGICAL, TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG, TFLOAT, TDOUBLE.
    If a NULL comment
   pointer is given on input, then the comment string will not be returned.
\end{description}

\begin{verbatim}
  int fits_read_key / ffgky
      (fitsfile *fptr, int datatype, char *keyname, > DTYPE *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[7 ] Get a keyword value (with the appropriate datatype) and comment from
    the CHU.  If a NULL comment pointer is given on input, then the comment
   string will not be returned.
\end{description}

\begin{verbatim}
  int fits_read_key_str / ffgkys
      (fitsfile *fptr, char *keyname, > char *value, char *comment,
       int *status);

  NOTE: after calling the following routine, programs must explicitly free
        the memory allocated for 'longstr' after it is no longer needed.

  int fits_read_key_longstr / ffgkls
      (fitsfile *fptr, char *keyname, > char **longstr, char *comment,
             int *status)

  int fits_read_key_[log, lng, flt, dbl] / ffgky[ljed]
      (fitsfile *fptr, char *keyname, > DTYPE *numval, char *comment,
       int *status)
\end{verbatim}

\begin{description}
\item[8 ] Get a sequence of numbered keyword values.
\end{description}

\begin{verbatim}
  int fits_read_keys_str / ffgkns
      (fitsfile *fptr, char *keyname, int nstart, int nkeys,
       > char **value, int *nfound,  int *status)

  int fits_read_keys_[log, lng, flt, dbl] / ffgkn[ljed]
      (fitsfile *fptr, char *keyname, int nstart, int nkeys,
       > DTYPE *numval, int *nfound, int *status)
\end{verbatim}

\begin{description}
\item[9 ] Get the value of a floating point keyword, returning the integer and
    fractional parts of the value in separate routine arguments.
    This routine may be used to read any keyword but is especially
   useful for reading the 'triple precision' keywords written by ffpkyt.
\end{description}

\begin{verbatim}
  int fits_read_key_triple / ffgkyt
      (fitsfile *fptr, char *keyname, > long *intval, double *frac,
       char *comment, int *status)
\end{verbatim}


\subsection{ Modify Keyword Routines \label{FFMREC}}

Wild card characters, as described in the Read Keyword section, above,
may be used when specifying the name of the keyword to be modified.


\begin{description}
\item[1 ] Modify (overwrite) the nth 80-character header record in the CHU.
\end{description}

\begin{verbatim}
  int fits_modify_record / ffmrec
      (fitsfile *fptr, int keynum, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Modify (overwrite) the 80-character header record for the named keyword
    in the CHU.  This can be used to overwrite the name of the keyword as
   well as its value and comment fields.
\end{description}

\begin{verbatim}
  int fits_modify_card / ffmcrd
      (fitsfile *fptr, char *keyname, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Modify (overwrite) the name of an existing keyword in the CHU
   preserving the current value and comment fields.
\end{description}

\begin{verbatim}
  int fits_modify_name / ffmnam
      (fitsfile *fptr, char *oldname, char *newname, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Modify (overwrite) the comment field of an existing keyword in the CHU.
\end{description}

\begin{verbatim}
  int fits_modify_comment / ffmcom
      (fitsfile *fptr, char *keyname, char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Modify the value and comment fields of an existing keyword in the CHU.
    Optionally, one may modify only the value field and leave the comment
    field unchanged by setting the input COMMENT parameter equal to
   the ampersand character (\&).
\end{description}

\begin{verbatim}
  int fits_modify_key_str / ffmkys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status);

  int fits_modify_key_[log, lng] / ffmky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_modify_key_[flt, dbl, fixflt, fixdbl] / ffmky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}

\subsection{ Update Keyword Routines \label{FFUCRD}}

These update routines modify the value of the keyword if it already exists,
otherwise the new keyword is appended to the header.


\begin{description}
\item[1 ] Update an 80-character record in the CHU.
\end{description}

\begin{verbatim}
  int fits_update_card / ffucrd
      (fitsfile *fptr, char *keyname, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Update the value and comment fields of a keyword in the CHU.
\end{description}

\begin{verbatim}
  int fits_update_key_str / ffukys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_update_key_[log, lng] / ffuky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_update_key_[flt, dbl, fixflt, fixdbl] / ffuky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Delete Keyword Routines \label{FFDREC}}


\begin{description}
\item[1 ] Delete an existing keyword record.  The space previously occupied by
    the keyword is reclaimed by moving all the following header records up
    one row in the header.  The first routine deletes a keyword at a
    specified position in the header (the first keyword is at position 1),
    whereas the second routine deletes a specifically named keyword.
    Wild card characters, as described in the Read Keyword section, above,
    may be used when specifying the name of the keyword to be deleted
   (be careful!).
\end{description}

\begin{verbatim}
  int fits_delete_record / ffdrec
      (fitsfile *fptr, int   keynum,  > int *status)

  int fits_delete_key / ffdkey
      (fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}


\section{Data Scaling and Undefined Pixel Parameters  \label{FFPSCL}}

These routines define or modify the internal parameters used by
CFITSIO to either scale the data or to represent undefined pixels.
Generally CFITSIO will scale the data according to the values of the BSCALE
and BZERO (or TSCALn and TZEROn) keywords, however these routines
may be used to override the keyword values.  This may be useful when
one wants to read or write the raw unscaled values in the FITS file.
Similarly, CFITSIO generally uses the value of the BLANK or TNULLn
keyword to signify an undefined pixel, but these routines may be used
to override this value.  These routines do not create or modify the
corresponding header keyword values.


\begin{description}
\item[1 ] Reset the scaling factors in the primary array or image extension; does
    not change the BSCALE and BZERO keyword values and only affects the
    automatic scaling performed when the data elements are written/read
    to/from the FITS file.   When reading from a FITS file the returned
    data value = (the value given in the FITS array) * BSCALE + BZERO.
    The inverse formula is used when writing data values to the FITS
   file.
\end{description}

\begin{verbatim}
  int fits_set_bscale / ffpscl
      (fitsfile *fptr, double scale, double zero, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Reset the scaling parameters for a table column; does not change
    the TSCALn or TZEROn keyword values and only affects the automatic
    scaling performed when the data elements are written/read to/from
    the FITS file.  When reading from a FITS file the returned data
    value = (the value given in the FITS array) * TSCAL + TZERO.  The
   inverse formula is used when writing data values to the FITS file.
\end{description}

\begin{verbatim}
  int fits_set_tscale / fftscl
      (fitsfile *fptr, int colnum, double scale, double zero,
       > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Define the integer value to be used to signify undefined pixels in the
    primary array or image extension.  This is only used if BITPIX = 8, 16,
    or 32.  This does not create or change the value of the BLANK keyword in
   the header.
\end{description}

\begin{verbatim}
  int fits_set_imgnul / ffpnul
      (fitsfile *fptr, long nulval, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Define the string to be used to signify undefined pixels in
    a column in an ASCII table.  This does not create or change the value
   of the TNULLn keyword.
\end{description}

\begin{verbatim}
  int fits_set_atblnull / ffsnul
      (fitsfile *fptr, int colnum, char *nulstr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Define the value to be used to signify undefined pixels in
    an integer column in a binary table (where TFORMn = 'B', 'I', or 'J').
   This does not create or  change the value of the TNULLn keyword.
\end{description}

\begin{verbatim}
  int fits_set_btblnul / fftnul
      (fitsfile *fptr, int colnum, long nulval, > int *status)
\end{verbatim}


\section{FITS Primary Array or IMAGE Extension I/O Routines}

These routines put or get data values in the primary data array (i.e.,
the first HDU in the FITS file) or an IMAGE extension.   Automatic data
type conversion is performed for if the data type of the primary array
(as defined by the BITPIX keyword) differs from the data type of the
array in the calling routine.  The data values are also scaled by the
BSCALE and BZERO header values as they are being written or read from
the FITS array.

The more primitive reading and writing routines (i. e., ffppr\_,
ffppn\_, ffppn, ffgpv\_, or ffgpf\_) simply treat the primary
array as a long 1-dimensional array of pixels, ignoring the
intrinsic dimensionality of the array.  When dealing with
a 2D image, for example, the application program must calculate
the pixel offset in the 1-D array that corresponds to any
particular X, Y coordinate in the image.

For convenience, higher-level routines are also provided to specificly
deal with 2D images (ffp2d\_ and ffg2d\_) and 3D data cubes (ffp3d\_
and ffg3d\_).  The dimensionality of the FITS image is passed by the
naxis1, naxis2, and naxis3 parameters and the declared dimensions of
the program array are passed in the dim1 and dim2 parameters.  Note
that the dimensions of the program array may be larger than the
dimensions of the FITS array.  For example if a FITS image with NAXIS1
= NAXIS2 = 400 is read into a program array which is dimensioned as 512
x 512 pixels, then the image will just fill the lower left corner of
the array with pixels in the range 1 - 400 in the X an Y directions.
This has the effect of taking a contiguous set of pixel value in the
FITS array and writing them to a non-contiguous array in program memory
(i.e., there are now some blank pixels around the edge of the image in
the program array).

The most general set of routines (ffpss\_, ffgsv\_, and ffgsf\_) may be
used to transfer a rectangular subset of the pixels in a FITS
N-dimensional image to or from an array which has been declared in the
calling program.  The fpixels and lpixels parameters are integer arrays
which specify the starting and ending pixels in each dimension
(starting with 1, not 0) of the FITS image that is to be read or
written.  It is important to note that these are the starting and
ending pixels in the FITS image, not in the declared array in the
program. The array parameter in these routines is treated simply as a
large one-dimensional array of the appropriate datatype containing the
pixel values; The pixel values in the FITS array are read/written
from/to this program array in strict sequence without any gaps;  it is
up to the calling routine to correctly interpret the dimensionality of
this array.  The two FITS reading routines (ffgsv\_ and ffgsf\_ ) also
have an `inc' parameter which defines the data sampling interval in
each dimension of the FITS array.  For example, if inc[0]=2 and
inc[1]=3 when reading a 2-dimensional FITS image, then only every other
pixel in the first dimension and every 3rd pixel in the second
dimension will be returned to the 'array' parameter.

Two types of routines are provided to read the data array which differ
in the way undefined pixels are handled.  The first type of routines
(e.g., ffgpv\_) simply return an array of data elements in which
undefined pixels are set equal to a value specified by the user in the
`nulval' parameter.  An additional feature of these routines is that if
the user sets nulval = 0, then no checks for undefined pixels will be
performed, thus reducing the amount of CPU processing.  The second type
of routines (e.g., ffgpf\_) returns the data element array and, in
addition, a char array which defines whether the corresponding data
pixel is defined (= 1) or not (= 0).  The latter type of routines may
be more convenient to use in some circumstances, however, it requires
an additional array of logical values which can be unwieldy when
working with large data arrays.


\subsection{Write Image Data Routines \label{FFPPR}}

\begin{description}
\item[1 ] Put elements into the data array. The datatype parameter specifies
    the datatype of the array of values and can have one of the following
    symbolic constant values: TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG,
   TFLOAT, TDOUBLE.
\end{description}

\begin{verbatim}
  int fits_write_img / ffppr
      (fitsfile *fptr, int datatype, long firstelem, long nelements,
       DTYPE *array, int *status);
\end{verbatim}

\begin{description}
\item[2 ] Put elements into the data array.  The datatype is specified
   by the suffix of the name of the routine.
\end{description}

\begin{verbatim}
  int fits_write_img_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffppr[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       DTYPE *array, > int *status);
\end{verbatim}

\begin{description}
\item[3 ]Put elements into the data array, substituting the appropriate FITS null
   value for all elements which are equal to the value of NULLVAL.  For
   integer FITS arrays, the null value defined by the BLANK keyword or
   a previous call to ffpnul
   will be substituted;  for floating point FITS arrays (BITPIX = -32
   or -64) then the special IEEE NaN (Not-a-Number) value will be
  substituted.
\end{description}

\begin{verbatim}
  int fits_write_imgnull_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffppn[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, DTYPE nulval, > int *status);
\end{verbatim}

\begin{description}
\item[4 ]Set data array elements as undefined.
\end{description}

\begin{verbatim}
  int fits_write_img_null / ffppru
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Put values into group parameters.  This routine only applies
    to the `Random Grouped' FITS format which has been used for
    applications in radio interferometry, but is offically deprecated
   for future use.
\end{description}

\begin{verbatim}
  int fits_write_grppar_[byt, sht, usht, int, lng, ulng, flt, dbl] /
      ffpgp[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put 2-D image into the data array.
\end{description}

\begin{verbatim}
  int fits_write_2d_[byt, sht, usht, lng, ulng, flt, dbl] /
      ffp2d[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long dim1, long naxis1,
       long naxis2, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Put 3-D cube into the data array.
\end{description}

\begin{verbatim}
  int fits_write_3d_[byt, sht, usht, lng, ulng, flt, dbl] /
      ffp3d[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long dim1, long dim2,
       long naxis1, long naxis2, long naxis3, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[8 ]   Put an arbitrary data subsection into the data array.
\end{description}

\begin{verbatim}
  int fits_write_subset_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffpss[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long naxis, long *naxes,
       long *fpixel, long *lpixel, DTYPE *array, > int *status)
\end{verbatim}


\subsection{ Read Image Data Routines \label{FFGPV}}


\begin{description}
\item[1 ] Get elements from the data array.  The `datatype' parameter specifies
    the datatype of the `nulval' parameter and of the `array' of values; it
    can have one of the following symbolic constant values:  TBYTE, TSHORT,
    TUSHORT, TINT, TLONG, TULONG, TFLOAT, TDOUBLE.  Undefined array
    elements will be returned with a value = *nullval, (note that this
    parameter gives the address of the null value, not the null value
    itself) unless nulval = 0 or *nulval = 0, in which case no checks for
   undefined pixels will be performed.
\end{description}

\begin{verbatim}
  int fits_read_img / ffgpv
      (fitsfile *fptr, int  datatype, long firstelem, long nelements,
       DTYPE *nulval, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get elements from the data array.  Undefined array elements will be
    returned with a value = nullval, unless nullval = 0 in which case no
   checks for undefined pixels will be performed.
\end{description}

\begin{verbatim}
  int fits_read_img_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffgpv[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       DTYPE nulval, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get elements and nullflags from data array.
    Any undefined array elements will have the corresponding nularray element
   set equal to 1, else 0.
\end{description}

\begin{verbatim}
  int  fits_read_imgnull_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffgpf[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get values from group parameters.  This routine only applies
    to the `Random Grouped' FITS format which has been used for
    applications in radio interferometry, but is offically deprecated
   for future use.
\end{description}

\begin{verbatim}
  int  fits_read_grppar_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffggp[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, int *status)
\end{verbatim}

\begin{description}
\item[5 ]  Get 2-D image from the data array.  Undefined
     pixels in the array will be set equal to the value of 'nulval',
     unless nulval=0 in which case no testing for undefined pixels will
    be performed.
\end{description}

\begin{verbatim}
  int  fits_read_2d_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffg2d[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, long group, DTYPE nulval, long dim1, long naxis1,
       long naxis2, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get 3-D cube from the data array.   Undefined
    pixels in the array will be set equal to the value of 'nulval',
    unless nulval=0 in which case no testing for undefined pixels will
   be performed.
\end{description}

\begin{verbatim}
  int  fits_read_3d_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffg3d[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, long group, DTYPE nulval, long dim1,
       long dim2, long naxis1, long naxis2, long naxis3,
       > DTYPE *array, int *anynul, int *status)
\end{verbatim}


\begin{description}
\item[7 ]   Get an arbitrary data subsection from the data array.  Undefined
       pixels in the array will be set equal to the value of 'nulval',
       unless nullval=0 in which case no testing for undefined pixels will
      be performed.
\end{description}

\begin{verbatim}
  int  fits_read_subset_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffgsv[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, int group, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, DTYPE nulval,
       > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[8 ]   Get an arbitrary data subsection from the data array.  Any Undefined
       pixels in the array will have the corresponding 'nularray'
      element set equal to TRUE.
\end{description}

\begin{verbatim}
  int  fits_read_subsetnull_[byt, sht, usht, lng, ulng, int, flt, dbl] /
       ffgsf[b,i,ui,j,uj,k,e,d]
       (fitsfile *fptr, int group, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}


\section{FITS ASCII and Binary Table Data I/O Routines}


\subsection{Column Information Routines \label{FFGCNO}}


\begin{description}
\item[1 ] Get the table column number (and name) of the column whose name
matches an input template name.  The table column names are defined by
the TTYPEn keywords in the FITS header.  If a column does not have a
TTYPEn keyword, then these routines assume that the name consists of
all blank characters.  These 2 routines perform the same function
except that ffgcno only returns the number of the matching column whereas
ffgcnn also returns the name of the column.  If casesen = TRUE then
the column name match will be case-sensitive.

The input column name template (templt) is either the exact name of the
column to be searched for, or it may contain wild card characters (*,
?, or \#), or it may contain the integer number of the desired column
(where the number is expressed as ASCII digits).  The first 2 wild
cards behave similarly to UNIX filename matching:  the '*' character
matches any sequence of characters (including zero characters) and the
'?' character matches any single character.  The \# wildcard will match
any consecutive string of decimal digits (0-9).  As an example, the template
strings `AB?DE', `AB*E', and `AB*CDE' will all match the string
'ABCDE'.  If more than one column name in the table matches the
template string, then the first match is returned and the status value
will be set to COL\_NOT\_UNIQUE (237) as a warning that a unique match
was not found.  To find the other cases that match the template, simply
call the routine again leaving the input status value equal to 237 and
the next matching name will then be returned.  Repeat this process
until a status = COL\_NOT\_FOUND (219) is returned.  If these routines
fail to match the template to any of the columns in the table, they
lastly check if the template can be interpreted as a simple positive
integer (e.g., '7', or '512') and if so, they return that column
number.  If no matches are found then a status = COL\_NOT\_FOUND (219)
error is returned.

Note that the FITS Standard recommends that only letters, digits, and
the underscore character be used in column names (with no embedded
spaces in the name).  Trailing blank characters are not significant.
It is recommended that the column names in a given table be unique
within the first 8 characters, and HIGHLY recommended that the names be
unique withing the first 16 characters.
\end{description}

\begin{verbatim}
  int fits_get_colnum / ffgcno
      (fitsfile *fptr, int casesen, char *templt, > int *colnum,
       int *status)

  int fits_get_colname / ffgcnn
      (fitsfile *fptr, int casesen, char *templt, > char *colname,
       int *colnum, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get the datatype of a column in an ASCII or binary table.  This routine
    returns an integer code value corresponding to the datatype of the column.
    (See the ffbnfm and ffasfm routines in the Utilities section of this
    document for a list of the code values).  The negative of the code value is
    returned if it is a variable length array column. The vector
    repeat count (which is alway 1 for ASCII table columns) is also returned.
    If the specified column has an ASCII character datatype (code = 16) then
    the width of a unit string in the column is also returned.  Note that
    this routine supports the local convention for specifying arrays of
    strings within a binary table character column, using the syntax
    TFORM = 'rAw' where 'r' is the total number of characters (= the width
    of the column) and 'w' is the width of a unit string within the column.
    Thus if the column has TFORM = '60A12' then this routine will return
   typecode = 16, repeat = 60, and width = 12.
\end{description}

\begin{verbatim}
  int fits_get_coltype / ffgtcl
      (fitsfile *fptr, int colnum, > int *typecode, long *repeat,
       long *width, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get information about an existing ASCII table column.
\end{description}

\begin{verbatim}
int fits_get_acolparms / ffgacl
    (fitsfile *fptr, int colnum, > char *ttype, long *tbcol,
     char *tunit, char *tform, double *scale, double *zero,
     char *nulstr, char *tdisp, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get information about an existing binary table column. DATATYPE is a
    character string which returns the datatype of the column as defined
    by the TFORMn keyword (e.g., 'I', 'J','E', 'D', etc.).  In the case
    of an ASCII character column, typecode will have a value of the
    form 'An' where 'n' is an integer expressing the width of the field
    in characters.  For example, if TFORM = '160A8' then ffgbcl will return
    typechar='A8' and repeat=20.   All the returned parameters are scalar
   quantities.
\end{description}

\begin{verbatim}
  int fits_get_bcolparms / ffgbcl
      (fitsfile *fptr, int colnum, > char *ttype, char *tunit,
       char *typechar, long *repeat, double *scale, double *zero,
       long *nulval, char *tdisp, int  *status)
\end{verbatim}

\begin{description}
\item[ 5] Put (append) a TDIMn keyword whose value has the form '(l,m,n...)'
    where l, m, n... are the dimensions of a multidimension array
   column in a binary table.
\end{description}

\begin{verbatim}
  int fits_write_tdim / ffptdm
      (fitsfile *fptr, int colnum, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[ 6] Return the number of and size of the dimensions of a table column.
    Normally this information is given by the TDIMn keyword, but if
    this keyword is not present then this routine returns naxis = 1
   and naxes[0] equal to the repeat count in the TFORM keyword.
\end{description}

\begin{verbatim}
  int fits_read_tdim / ffgtdm
      (fitsfile *fptr, int colnum, int maxdim, > int *naxis,
       long *naxes, int *status)
\end{verbatim}

\begin{description}
\item[ 7] Return optimal number of rows to read or write at one time for
    maximum I/O efficiency.  Refer to the
    ``Optimizing Code'' section in Chapter 5 for more discussion on how
   to use this routine.
\end{description}

\begin{verbatim}
  int fits_get_rowsize / ffgrsz
      (fitsfile *fptr, long *nrows, *status)
\end{verbatim}


\subsection{Low-Level Table Access Routines \label{FFGTBB}}

The following 2 routines provide low-level access to the data in ASCII
or binary tables and are mainly useful as an efficient way to copy all
or part of a table from one location to another.  These routines simply
read or write the specified number of consecutive bytes in an ASCII or
binary table, without regard for column boundaries or the row length in
the table.  These routines do not perform any machine dependent data
conversion or byte swapping.


\begin{description}
\item[1 ] Read a consecutive array of bytes from an ASCII or binary table
\end{description}

\begin{verbatim}
  int fits_read_tblbytes / ffgtbb
      (fitsfile *fptr, long firstrow, long firstchar, long nchars,
       > unsigned char *values, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Write a consecutive array of bytes to an ASCII or binary table
\end{description}

\begin{verbatim}
  int fits_write_tblbytes / ffptbb
      (fitsfile *fptr, long firstrow, long firstchar, long nchars,
       unsigned char *values, > int *status)
\end{verbatim}

\subsection{ Insert or Delete Rows and Columns Routines \label{FFIROW}}


\begin{description}
\item[1 ] Insert blank rows into an existing ASCII or binary table (in the CDU).
    All the rows FOLLOWING row FROW are shifted down by NROWS rows.  If
    FROW = 0 then the blank rows are inserted at the beginning of the
    table.  This routine modifies the NAXIS2 keyword to reflect the new
   number of rows in the table.
\end{description}

\begin{verbatim}
  int fits_insert_rows / ffirow
      (fitsfile *fptr, long firstrow, long nrows, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Delete rows from an existing ASCII or binary table (in the CDU).
    The NROWS number of rows are deleted, starting with row FROW, and
    any remaining rows in the table are shifted up to fill in the space.
    This routine modifies the NAXIS2 keyword to reflect the new number
    of rows in the table.  Note that the physical size of the FITS file will
    not be reduced by this operation, and the empty FITS blocks if any
   at the end of the file will be padded with zeros.
\end{description}

\begin{verbatim}
  int fits_delete_rows / ffdrow
      (fitsfile *fptr, long firstrow, long nrows, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Insert a blank column (or columns) into an existing ASCII or binary
    table (in the CDU).  COLNUM specifies the column number that the (first)
    new column should occupy in the table.  NCOLS specifies how many
    columns are to be inserted. Any existing columns from this position and
    higher are moved over to allow room for the new column(s).
    The index number on all the following keywords will be incremented
    if necessary to reflect the new position of the column(s) in the table:
    TBCOLn, TFORMn, TTYPEn, TUNITn, TNULLn, TSCALn, TZEROn, TDISPn, TDIMn,
    TLMINn, TLMAXn, TDMINn, TDMAXn, TCTYPn, TCRPXn, TCRVLn, TCDLTn, TCROTn,
   and TCUNIn.
\end{description}

\begin{verbatim}
  int fits_insert_col / fficol
      (fitsfile *fptr, int colnum, char *ttype, char *tform,
       > int *status)

  int fits_insert_cols / fficls
      (fitsfile *fptr, int colnum, int ncols, char **ttype,
       char **tform, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Delete a column from an existing ASCII or binary table (in the CDU).
    The index number of all the keywords listed above (for fficol) will be
    decremented if necessary to reflect the new position of the column(s) in
    the table.  Those index keywords that refer to the deleted column will
    also be deleted.  Note that the physical size of the FITS file will
    not be reduced by this operation, and the empty FITS blocks if any
   at the end of the file will be padded with zeros.
\end{description}

\begin{verbatim}
  int fits_delete_col / ffdcol(fitsfile *fptr, int colnum, > int *status)
\end{verbatim}

\subsection{ Write Column Data Routines \label{FFPCLS}}

The following routines put or get data values in the current ASCII or
Binary table extension.  Automatic data type conversion is performed
for numerical data types (B,I,J,E,D) if the data type of the column
(defined by the TFORM keyword) differs from the data type of the
calling routine.  The data values are also scaled by the TSCALn and
TZEROn header values as they are being written to or read from the FITS
array.  The fftscl routine MUST be used to define the scaling
parameters when writing data to the table or to override the default
scaling values given in the header when reading from the table.

    In the case of binary tables with vector elements, the 'felem'
parameter defines the starting pixel within the element vector.  This
parameter is ignored with ASCII tables. Similarly, in the case of
binary tables the 'nelements' parameter specifies the total number of
vector values read or written (continuing on subsequent rows if
required) and not the number of table elements.


\begin{description}
\item[1 ] Put elements into an ASCII or binary table column (in the CDU).
    The `datatype' parameter specifies the datatype of the `array' of
    values and can have one of the following symbolic constant values:
    TSTRING, TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG, TFLOAT, or
    TDOUBLE.  Binary tables also support the following additional
   datatypes: TBIT, TLOGICAL, TCOMPLEX, and TDBLCOMPLEX.
\end{description}

\begin{verbatim}
  int fits_write_col / ffpcl
      (fitsfile *fptr, int datatype, int colnum, long firstrow,
       long firstelem, long nelements, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Put elements into an ASCII or binary table column (in the CDU).
    The datatype of the array is implied by the suffix of the
   routine name.
\end{description}

\begin{verbatim}
  int fits_write_col_str / ffpcls
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, char **array, > int *status)

  int fits_write_col_[log, byt, sht, usht, lng, ulng, int, flt, dbl, cmp, dblcmp] /
      ffpcl[l,b,i,ui,j,uj,k,e,d,c,m]
      (fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Put elements into an ASCII or binary table column (in the CDU)
    substituting the appropriate FITS null value for any elements that
    are equal to NULLVAL.  This family of routines must NOT be used to
    write to  variable length array columns. For ASCII TABLE extensions, the
    null value defined by the previous call to ffsnul will be substituted;
    For integer FITS columns, in a binary table  the null value
    defined by the previous call to fftnul will be substituted;
    For floating point FITS columns a special IEEE NaN (Not-a-Number)
   value will be substituted.
\end{description}

\begin{verbatim}
  int fits_write_colnul_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffpcn[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE *array, DTYPE nulval, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Put bit values into a binary byte ('B') or bit ('X') table column (in the
    CDU).  Larray is an array of logical values corresponding to the sequence of
    bits to be written.  If larray is true then the corresponding bit is
    set to 1, otherwise the bit is set to 0.  Note that in the case of
    'X' columns, CFITSIO can write to all 8 bits of each byte whether
    they are formally valid or not.  Thus if the column is defined as
    '4X', and one calls ffpclx with  firstbit=1 and nbits=8, then all 8 bits
    will be written into the first byte (as opposed to writing the
    first 4 bits into the first row and then the next 4 bits into the
    next row), even though the last 4 bits of each byte are formally
   not defined.
\end{description}

\begin{verbatim}
  int fits_write_col_bit / ffpclx
      (fitsfile *fptr, int colnum, long firstrow, long firstbit,
       long nbits, char *larray, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Set table elements in a column as undefined
\end{description}

\begin{verbatim}
   int fits_write_col_null / ffpclu
       (fitsfile *fptr, int colnum, long firstrow, long firstelem,
        long nelements, > int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put the descriptor for a variable length column in a binary table.
    This routine can be used in conjunction with FFGDES to enable
    2 or more arrays to point to the same storage location to save
   storage space if the arrays are identical.
\end{description}

\begin{verbatim}
    int fits_write_descript / ffpdes
        (fitsfile *fptr, int colnum, long rownum, long repeat,
         long offset, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Define the zero indexed byte offset of the 'heap' measured from
    the start of the binary table data.  By default the heap is assumed
    to start immediately following the regular table data, i.e., at
    location NAXIS1 x NAXIS2.  This routine is only relevant for
    binary tables which contain variable length array columns (with
    TFORMn = 'Pt').  This routine also automatically writes
    the value of theap to a keyword in the extension header.  This
    routine must be called after the required keywords have been
    written (with ffphbn) and after the table structure has been defined
   (with ffbdef) but before any data is written to the table.
\end{description}

\begin{verbatim}
  int fits_write_theap / ffpthp
      (fitsfile *fptr, long theap, > int *status)
\end{verbatim}

\subsection{ Read Column Data Routines \label{FFGCL}}

Two types of routines are provided to get the column data which differ
in the way undefined pixels are handled.  The first set of routines
(ffgcv) simply return an array of data elements in which undefined
pixels are set equal to a value specified by the user in the 'nullval'
parameter.  An additional feature of these routines is that if the user
sets nullval = 0, then no checks for undefined pixels will be
performed, thus increasing the speed of the program.  The second set of
routines (ffgcf) returns the data element array and in addition a
logical array of flags which defines whether the corresponding data
pixel is undefined.


\begin{description}
\item[1 ] Get elements from an ASCII or binary table column (in the CDU).  The
    `datatype' parameter specifies the datatype of the `nulval' parameter
    and of the `array' of values; it can have one of the following symbolic
    constant values:  TSTRING, TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG,
    TFLOAT, or TDOUBLE.  Binary tables also support the following
    additional datatypes: TBIT, TLOGICAL, TCOMPLEX, and TDBLCOMPLEX.
    Undefined array elements will be returned with a value = *nullval,
    (note that this parameter gives the address of the null value, not the
    null value itself) unless nulval = 0 or *nulval = 0, in which case no
   checks for undefined pixels will be performed.
\end{description}

\begin{verbatim}
  int fits_read_col / ffgcv
      (fitsfile *fptr, int datatype, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE *nulval, DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get elements from an ASCII or binary table column (in the CDU).  These
    routines return the values of the table column array elements.  Undefined
    array elements will be returned with a value = nulval, unless nulval = 0
    (or = ' ' for ffgcvs) in which case no checking for undefined values will
    be performed. The ANYF parameter is set to true if any of the returned
    elements are undefined. (Note: the ffgcl routine simple gets an array
    of logical data values without any checks for undefined values;  use
   the ffgcfl routine to check for undefined logical elements).
\end{description}

\begin{verbatim}
  int fits_read_col_log / ffgcl
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char *array, int  *status)

  int fits_read_col_str / ffgcvs
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, char *nulstr, > char **array, int *anynul,
       int *status)

  int fits_read_col_[byt, sht, usht, lng, ulng, int, flt, dbl, cmp, dblcmp] /
      ffgcv[b,i,ui,j,uj,k,e,d,c,m]
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE nulval, > DTYPE *array, int *anynul,
       int *status)
\end{verbatim}

\begin{description}
\item[3 ]  Get elements and null flags from an ASCII or binary table column (in the
    CHDU).  These routines return the values of the table column array elements.
    Any undefined array elements will have the corresponding nularray element
    set equal to TRUE.  The anynul parameter is set to true if any of the
   returned elements are undefined.
\end{description}

\begin{verbatim}
  int fits_read_colnull_str / ffgcfs
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char **array, char *nularray, int *anynul,
       int *status)

  int fits_read_colnull_log / ffgcfl
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char *array, char *nularray, int *anynul,
       int *status)

  int fits_read_colnull_[byt, sht, usht, lng, ulng, int, flt, dbl, cmp, dblcmp] /
      ffgcf[b,i,ui,j,uj,k,e,d,c,m]
      (fitsfile *fptr, int colnum, long firstrow,
       long firstelem, long nelements, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get an arbitrary data subsection from an N-dimensional array
    in a binary table vector column.  Undefined pixels
    in the array will be set equal to the value of 'nulval',
    unless nulval=0 in which case no testing for undefined pixels will
    be performed.  The first and last rows in the table to be read
    are specified by fpixels(naxis+1) and lpixels(naxis+1), and hence
    are treated as the next higher dimension of the FITS N-dimensional
    array.  The INC parameter specifies the sampling interval in
   each dimension between the data elements that will be returned.
\end{description}

\begin{verbatim}
  int fits_read_subset_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffgsv[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, int colnum, int naxis, long *naxes, long *fpixels,
       long *lpixels, long *inc, DTYPE nulval, > DTYPE *array, int *anynul,
       int *status)
\end{verbatim}

\begin{description}
\item[5 ] Get an arbitrary data subsection from an N-dimensional array
    in a binary table vector column.  Any Undefined
    pixels in the array will have the corresponding 'nularray'
    element set equal to TRUE.  The first and last rows in the table
    to be read are specified by fpixels(naxis+1) and lpixels(naxis+1),
    and hence are treated as the next higher dimension of the FITS
    N-dimensional array.  The INC parameter specifies the sampling
    interval in each dimension between the data elements that will be
   returned.
\end{description}

\begin{verbatim}
  int fits_read_subsetnull_[byt, sht, usht, lng, ulng, int, flt, dbl] /
      ffgsf[b,i,ui,j,uj,k,e,d]
      (fitsfile *fptr, int colnum, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get bit values from a byte ('B') or bit (`X`) table column (in the
    CDU).  Larray is an array of logical values corresponding to the
    sequence of bits to be read.  If larray is true then the
    corresponding bit was set to 1, otherwise the bit was set to 0.
    Note that in the case of 'X' columns, CFITSIO can read  all 8 bits
    of each byte whether they are formally valid or not.  Thus if the
    column is defined as '4X', and one calls ffgcx with  firstbit=1 and
    nbits=8, then all 8 bits will be read from the first byte (as
    opposed to reading the first 4 bits from the first row and then the
    first 4 bits from the next row), even though the last 4 bits of
   each byte are formally not defined.
\end{description}

\begin{verbatim}
  int fits_read_col_bit / ffgcx
      (fitsfile *fptr, int colnum, long firstrow, long firstbit,
       long nbits, > char *larray, int *status)
\end{verbatim}

\begin{description}
\item[7 ] Get the descriptor for a variable length column in a binary table.
    The descriptor consists of 2 integer parameters: the number of elements
   in the array and the starting offset relative to the start of the heap.
\end{description}

\begin{verbatim}
  int fits_read_descript / ffgdes
      (fitsfile *fptr, int colnum, long rownum, > long *repeat,
           long *offset, int *status)
\end{verbatim}


\section{Celestial Coordinate System Routines \label{FFGICS}}

The following routines are provided to help calculate the
transformation between pixel location in an image and the corresponding
celestial coordinates on the sky.  These support the following standard
map projections:  -SIN, -TAN, -ARC, -NCP, -GLS, -MER, and -AIT (these
are the legal values for the coordtype parameter).  These routines are
based on similar functions in Classic AIPS.  All the angular quantities
are given in units of degrees.


\begin{description}
\item[1 ] Get the values of all the standard FITS celestial coordinate system
    keywords from the header of a FITS image (i.e., the primary array or
    an image extension).  These values may then be passed to the routines
   that perform the coordinate transformations.
\end{description}

\begin{verbatim}
  int fits_read_img_coord / ffgics
      (fitsfile *fptr, > double *xrefval, double *yrefval,
       double *xrefpix, double *yrefpix, double *xinc, double *yinc,
       double *rot, char *coordtype, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get the values of all the standard FITS celestial coordinate system
    keywords from the header of a FITS table where the X and Y (or RA and
    DEC coordinates are stored in 2 separate columns of the table.
    These values may then be passed to the routines that perform the
   coordinate transformations.
\end{description}

\begin{verbatim}
  int fits_read_tbl_coord / ffgtcs
      (fitsfile *fptr, int xcol, int ycol, > double *xrefval,
       double *yrefval, double *xrefpix, double *yrefpix, double *xinc,
       double *yinc, double *rot, char *coordtype, int *status)
\end{verbatim}

\begin{description}
\item[3 ]  Calculate the celestial coordinate corresponding to the input
    X and Y pixel location in the image.
\end{description}

\begin{verbatim}
  int fits_pix_to_world / ffwldp
      (double xpix, double ypix, double xrefval, double yrefval,
       double xrefpix, double yrefpix, double xinc, double yinc,
       double rot, char *coordtype, > double *xpos, double *ypos,
       int *status)
\end{verbatim}

\begin{description}
\item[4 ]  Calculate the X and Y pixel location corresponding to the input
    celestial coordinate in the image.
\end{description}

\begin{verbatim}
  int fits_world_to_pix / ffxypx
      (double xpos, double ypos, double xrefval, double yrefval,
       double xrefpix, double yrefpix, double xinc, double yinc,
       double rot, char *coordtype, double *xpix, double *ypix,
       int *status)
\end{verbatim}


\section{File Checksum Routines \label{FFPCKS}}

The following routines either compute or validate the checksums for the
CHDU.  The DATASUM keyword is used to store the numerical value of the
32-bit, 1's complement checksum for the data unit alone.  If there is
no data unit then the value is set to zero. The numerical value is
stored as an ASCII string of digits, enclosed in quotes, because the
value may be too large to represent as a 32-bit signed integer.  The
CHECKSUM keyword is used to store the ASCII encoded COMPLEMENT of the
checksum for the entire HDU.  Storing the complement, rather than the
actual checksum, forces the checksum for the whole HDU to equal zero.
If the file has been modified since the checksums were computed, then
the HDU checksum will usually not equal zero.  These checksum keyword
conventions are based on a paper by Rob Seaman published in the
proceedings of the ADASS IV conference in Baltimore in November 1994
and a later revision in June 1995.


\begin{description}
\item[1 ] Compute and write the DATASUM and CHECKSUM keyword values for the CHDU
    into the current header.  If the keywords already exist, their values
    will be updated only if necessary (i.e., if the file
    has been modified since the original keyword
   values were computed).
\end{description}

\begin{verbatim}
  int fits_write_chksum / ffpcks
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Update the CHECKSUM keyword value in the CHDU, assuming that the
    DATASUM keyword exists and already has the correct value.  This routine
    calculates the new checksum for the current header unit, adds it to the
    data unit checksum, encodes the value into an ASCII string, and writes
   the string to the CHECKSUM keyword.
\end{description}

\begin{verbatim}
  int fits_update_chksum / ffupck
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Verify the CHDU by computing the checksums and comparing
    them with the keywords.  The data unit is verified correctly
    if the computed checksum equals the value of the DATASUM
    keyword.  The checksum for the entire HDU (header plus data unit) is
    correct if it equals zero.  The output DATAOK and HDUOK parameters
    in this routine are integers which will have a value = 1
    if the data or HDU is verified correctly, a value = 0
    if the DATASUM or CHECKSUM keyword is not present, or value = -1
   if the computed checksum is not correct.
\end{description}

\begin{verbatim}
  int fits_verify_chksum / ffvcks
      (fitsfile *fptr, > int *dataok, int *hduok, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Compute and return the checksum values for the CHDU (as
    double precision variables) without creating or modifying the
    CHECKSUM and DATASUM keywords.  This routine is used internally by
   ffvcks, but may be useful in other situations as well.
\end{description}

\begin{verbatim}
  int fits_get_chksum/ /ffgcks
      (fitsfile *fptr, > unsigned long *datasum, unsigned long *hdusum,
       int *status)
\end{verbatim}

\begin{description}
\item[5 ] Encode a checksum value (stored in a double precision variable)
    into a 16-character string.  If COMPLEMENT = .true. then the 32-bit
   sum value will be complemented before encoding.
\end{description}

\begin{verbatim}
  int fits_encode_chksum / ffesum
      (unsigned long sum, int complm, > char *ascii);
\end{verbatim}

\begin{description}
\item[6 ] Decode a 16-character checksum string into a unsigned long value.
    If COMPLEMENT = .true. then the 32-bit sum value will be complemented
    after decoding.  The checksum value is also returned as the
   value of the function.
\end{description}

\begin{verbatim}
  unsigned long fits_decode_chksum / ffdsum
           (char *ascii, int complm, > unsigned long *sum);
\end{verbatim}


\section{General Utility Routines \label{FFVERS}}

The following utility routines may be useful for certain applications:


\begin{description}
\item[1 ] Return the revision number of the fitsio library.
    This routine returns the current revision number of the CFITSIO
    software library.  The revision number will be incremented whenever any
   modifications or enhancements are made to the code.
\end{description}

\begin{verbatim}
  float fits_get_version ffvers
       ( > float *version)
\end{verbatim}

\begin{description}
\item[2 ] Return the starting byte address of the CHDU and the next HDU.
\end{description}

\begin{verbatim}
  void fits_get_hduaddr / ffghad
       (fitsfile *fptr, > long *chduaddr, long *nextaddr)
\end{verbatim}

\begin{description}
\item[3 ] Return a descriptive text string corresponding to a CFITSIO error
    status code.   The 30-character length string contains a brief
   description of the cause of the error.
\end{description}

\begin{verbatim}
 void fits_get_errstatus / ffgerr (int status, > char *err_text)
\end{verbatim}

\begin{description}
\item[4 ] Return the top (oldest) 80-character error message from the
    internal CFITSIO stack of error messages and shift any remaining
    messages on the stack up one level.  Any CFITSIO error will
    generate one or more messages on the stack.  Call this routine
    repeatedly to get each message in sequence.  The error stack is empty
   when a blank string is returned or the routine returns a value of zero.
\end{description}

\begin{verbatim}
  int fits_read_errmsg / ffgmsg (char *err_msg)
\end{verbatim}

\begin{description}
\item[5 ] Write an 80-character message to the CFITSIO error stack.  Application
    programs should not normally write to the stack, but there may be
   some situations where this is desirable.
\end{description}

\begin{verbatim}
  void fits_write_errmsg / ffpmsg (char *err_msg)
\end{verbatim}

\begin{description}
\item[6 ]  Clear the entire error message stack.  This routine is useful
     to clear any error message that may have been generated by
     a non-fatal CFITSIO error (such as failing to find an optional
    header keyword).  This routine is called without any arguments.
\end{description}

\begin{verbatim}
  void fits_clear_errmsg / ffcmsg (void)
\end{verbatim}

\begin{description}
\item[7 ] Convert a character string to uppercase (operates in place).
\end{description}

\begin{verbatim}
  void fits_uppercase / ffupch (char *string)
\end{verbatim}

\begin{description}
\item[8 ]  Compare the input template string against the reference string
    to see if they match.  The template string may contain wildcard
    characters: '*' will match any sequence of characters (including
    zero characters) and '%' will match any single character in the
    reference string.  If CASESN = .true. then the match will be
    case sensitive.  The returned MATCH parameter will be .true. if
    the 2 strings match, and EXACT will be .true. if the match is
    exact (i.e., if no wildcard characters were used in the match).
   Both strings must be 68 characters or less in length.
\end{description}

\begin{verbatim}
  void fits_compare_str / ffcmps
       (char *templt, char *string, int casesen, > int *match, int *exact)
\end{verbatim}


\begin{description}
\item[9 ] Test that the keyword name contains only legal characters: A-Z,0-9,
   hyphen, and underscore.
\end{description}

\begin{verbatim}
  int fits_test_keyword / fftkey (char *keyname, > int *status)
\end{verbatim}

\begin{description}
\item[10] Parse a header keyword record.
    This routine parses the input header record to return the value (as
    a character string) and comment strings.  If the keyword has no
    value (columns 9-10 not equal to '= '), then the value string is returned
    blank and the comment string is set equal to column 9 - 80 of the
   input string.
\end{description}

\begin{verbatim}
  int fits_parse_value / ffpsvc
      (char *card, > char *value, char *comment, int *status)
\end{verbatim}

\begin{description}
\item[11] Construct a sequence keyword name (ROOT + nnn).
    This routine appends the sequence number to the root string to create
   a keyword name (e.g., 'NAXIS' + 2 = 'NAXIS2')
\end{description}

\begin{verbatim}
  int fits_make_keyn / ffkeyn
      (char *keyroot, int value, > char *keyname, int *status)
\end{verbatim}

\begin{description}
\item[12] Construct a sequence keyword name (n + ROOT).
    This routine concatenates the sequence number to the front of the
   root string to create a keyword name (e.g., 1 + 'CTYP' = '1CTYP')
\end{description}

\begin{verbatim}
  int fits_make_nkey / ffnkey
      (int value, char *keyroot, > char *keyname, int *status)
\end{verbatim}

\begin{description}
\item[13] Determine the datatype of a keyword value string.
    This routine parses the keyword value string (usually columns 11-30
   of the header record) to determine its datatype.
\end{description}

\begin{verbatim}
  int fits_get_keytype / ffdtyp
      (char *value, > char *dtype, int *status)
\end{verbatim}

\begin{description}
\item[14] Parse the 'TFORM' binary table column format string.
    This routine parses the input TFORM character string and returns the
    integer datatype code, the repeat count of the field, and, in the case
    of character string fields, the length of the unit string.  See Chapter
   9 for the allowed values for the returned typecode parameter:
\end{description}

\begin{verbatim}
   int fits_binary_tform / ffbnfm
       (char *tform, > int *typecode, long *repeat, long *width,
        int *status)
\end{verbatim}

\begin{description}
\item[15] Parse the 'TFORM' keyword value that defines the column format in
    an ASCII table.  This routine parses the input TFORM character
    string and returns the datatype code, the width of the column,
    and (if it is a floating point column) the number of decimal places
    to the right of the decimal point.  The returned datatype codes are
    the same as for the binary table, with the following
    additional rules:  integer columns that are between 1 and 4 characters
    wide are defined to be short integers (code = TSHORT).  Wider integer
    columns are defined to be regular integers (code = TLONG).  Similarly,
    Fixed decimal point columns (with TFORM = 'Fw.d') are defined to
    be single precision reals (code = TFLOAT) if w is between 1 and 7 characters
    wide, inclusive.  Wider 'F' columns will return a double precision
    data code (= TDOUBLE).  'Ew.d' format columns will have datacode = TFLOAT,
   and 'Dw.d' format columns will have datacode = TDOUBLE.
\end{description}

\begin{verbatim}
  int fits_ascii_tform / ffasfm
      (char *tform, > int *typecode, long *width, int *decimals,
       int *status)
\end{verbatim}

\begin{description}
\item[16] Calculate the starting column positions and total ASCII table width
    based on the input array of ASCII table TFORM values.  The SPACE input
    parameter defines how many blank spaces to leave between each column
    (it is recommended to have one space between columns for better human
   readability).
\end{description}

\begin{verbatim}
  int fits_get_tbcol / ffgabc
      (int tfields, char **tform, int space, > long *rowlen,
       long *tbcol, int *status)
\end{verbatim}

\begin{description}
\item[17] Parse a template string and return a formatted 80-character string
    suitable for appending to (or deleting from) a FITS header file.
    This routine is useful for parsing lines from an ASCII template file
    and reformatting them into legal FITS header records.  The formatted
    string may then be passed to the ffprec, ffmcrd, or ffdkey routines
   to append or modify a FITS header record.
\end{description}

\begin{verbatim}
  int fits_parse_template / ffgthd
      (char *templt, > char *card, int *keytype, int *status)
\end{verbatim}
    The input templt character string generally should contain 3 tokens:
    (1) the KEYNAME, (2) the VALUE, and (3) the COMMENT string.  The
    TEMPLATE string must adhere to the following format:


\begin{description}
\item[- ]     The KEYNAME token must begin in columns 1-8 and be a maximum  of 8
        characters long.  If the first 8 characters of the template line are
        blank then the remainder of the line is considered to be a FITS comment
        (with a blank keyword name).  A legal FITS keyword name may only
        contain the characters A-Z, 0-9, and '-' (minus sign) and
        underscore.  This routine will automatically convert any lowercase
        characters to uppercase in the output string.  If KEYNAME = 'COMMENT'
        or 'HISTORY' then the remainder of the line is considered to be a FITS
       COMMENT or HISTORY record, respectively.
\end{description}


\begin{description}
\item[- ]     The VALUE token must be separated from the KEYNAME token by one or more
        spaces and/or an '=' character.  The datatype of the VALUE token
        (numeric, logical, or character string) is automatically determined
        and  the output CARD string is formatted accordingly.  The value
        token may be forced to be interpreted as a string (e.g. if it is a
       string of numeric digits) by enclosing it in single quotes.
\end{description}


\begin{description}
\item[- ]     The COMMENT token is optional, but if present must be separated from
        the VALUE token by at least one blank space.  A leading '/' character
        may be used to mark the beginning of the comment field, otherwise the
        comment field begins with the first non-blank character following the
       value token.
\end{description}


\begin{description}
\item[- ]     One exception to the above rules is that if the first non-blank
        character in the template string is a minus sign ('-') followed
        by a single token, or a single token followed by an equal sign,
        then it is interpreted as the name of a keyword which is to be
       deleted from the FITS header.
\end{description}


\begin{description}
\item[- ]     The second exception is that if the template string starts with
        a minus sign and is followed by 2 tokens then the second token
        is interpreted as the new name for the keyword specified by
        first token.  In this case the old keyword name (first token)
        is returned in characters 1-8 of the returned CARD string, and
        the new keyword name (the second token) is returned in characters
        41-48 of the returned CARD string.  These old and new names
        may then be passed to the ffmnam routine which will change
       the keyword name.
\end{description}

    The keytype output parameter indicates how the returned CARD string
    should be interpreted:

\begin{verbatim}
        keytype                  interpretation
        -------          -------------------------------------------------
           -2            Modify the name of the keyword given in CARD(1:8)
                         to the new name given in CARD(41:48)

           -1            CARD(1:8) contains the name of a keyword to be deleted
                         from the FITS header.

            0            append the CARD string to the FITS header if the
                         keyword does not already exist, otherwise update
                         the value/comment if the keyword is already present
                         in the header.

            1            simply append this keyword to the FITS header (CARD
                         is either a HISTORY or COMMENT keyword).

            2            This is a FITS END record; it should not be written
                         to the FITS header because CFITSIO automatically
                         appends the END record when the header is closed.
\end{verbatim}
     EXAMPLES:  The following lines illustrate valid input template strings:

\begin{verbatim}
      INTVAL 7 This is an integer keyword
      RVAL           34.6   /     This is a floating point keyword
      EVAL=-12.45E-03  This is a floating point keyword in exponential notation
      lval F This is a boolean keyword
                  This is a comment keyword with a blank keyword name
      SVAL1 = 'Hello world'   /  this is a string keyword
      SVAL2  '123.5'  this is also a string keyword
      sval3  123+  /  this is also a string keyword with the value '123+    '
      # the following template line deletes the DATE keyword
      - DATE
      # the following template line modifies the NAME keyword to OBJECT
      - NAME OBJECT
\end{verbatim}

\chapter{   Summary of all CFITSIO User-Interface Routines }

 FITS File Open and Close Routines: page~\pageref{FFOPEN}

\begin{verbatim}
  int ffopen(fitsfile **fptr, const char *filename, int iomode, > int *status)
  int ffinit(fitsfile **fptr, const char *filename, > int *status)
  int ffflus(fitsfile *fptr, > int *status)
  int ffclos(fitsfile *fptr, > int *status)
  int ffdelt(fitsfile *fptr, > int *status)
\end{verbatim}
 HDU-Level Operations: page~\pageref{FFMAHD}

\begin{verbatim}
  int ffmahd(fitsfile *fptr, int hdunum, > int *hdutype, int *status)
  int ffmrhd(fitsfile *fptr, int nmove, > int *hdutype, int *status)
  int ffghdn(fitsfile *fptr, > int *hdunum)
  int ffcrim(fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffcrtb(fitsfile *fptr, int tbltype, long naxis2, int tfields,
      char **ttype, char **tform, char **tunit, char *extname, int *status)
  int ffcrhd(fitsfile *fptr, > int *status)
  int ffiimg(fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffitab(fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
         long *tbcol, char **tform, char **tunit, char *extname, > int *status)
  int ffibin(fitsfile *fptr, long nrows, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, long pcount, > int *status)
  int ffdhdu(fitsfile *fptr, > int *hdutype, int *status)
  int ffcopy(fitsfile *infptr, fitsfile *outfptr, int morekeys, > int *status)
  int ffcpdt(fitsfile *infptr, fitsfile *outfptr, > int *status)
  int ffrdef(fitsfile *fptr, > int *status)   (DEPRECATED)
\end{verbatim}
 Header Space and Position Routines: page~\pageref{FFHDEF}

\begin{verbatim}
  int ffhdef(fitsfile *fptr, int morekeys, > int *status)
  int ffghsp(fitsfile *fptr, > int *keysexist, int *morekeys, int *status)
  int ffghps(fitsfile *fptr, > int *keysexist, int *keynum, int *status)
\end{verbatim}
 Read or Write Standard Header Routines: page~\pageref{FFPHPS}

\begin{verbatim}
  int ffphps( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffphpr( fitsfile *fptr, int simple, int bitpix, int naxis, long *naxes,
            long pcount, long gcount, int extend, > int *status)
  int ffghpr(fitsfile *fptr, int maxdim, > int *simple, int *bitpix, int *naxis,
          long *naxes, long *pcount, long *gcount, int *extend, int *status)
  int ffphtb(fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
          long *tbcol, char **tform, char **tunit, char *extname, > int *status)
  int ffghtb(fitsfile *fptr,int maxdim, > long *rowlen, long *nrows,
           int *tfields, char **ttype, long *tbcol, char **tform, char **tunit,
           char *extname,  int *status)
  int ffphbn(fitsfile *fptr, long nrows, int tfields, char **ttype,
          char **tform, char **tunit, char *extname, long pcount, > int *status)
  int ffghbn(fitsfile *fptr, int maxdim, > long *nrows, int *tfields,
           char **ttype, char **tform, char **tunit, char *extname,
           long *pcount, int *status)
\end{verbatim}
 Write Keyword Routines: page~\pageref{FFPREC}

\begin{verbatim}
  int ffprec(fitsfile *fptr, char *card, > int *status)
  int ffpcom(fitsfile *fptr, char *comment, > int *status)
  int ffphis(fitsfile *fptr, char *history, > int *status)
  int ffpdat(fitsfile *fptr, > int *status)
  int ffpky(fitsfile *fptr, int datatype, char *keyname, DTYPE *value,
          char *comment, > int *status)
  int ffpkys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffpky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
                 > int *status)
  int ffpky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
  int ffpkls(fitsfile *fptr, char *keyname, char *longstr,
             char *comment, > int *status)
  int ffplsw(fitsfile *fptr, > int *status)
  int ffpkns(fitsfile *fptr, char *keyroot, int nstart, int nkeys,
             char **value, char **comment, > int *status)
  int ffpkn[lj](fitsfile *fptr, char *keyroot, int nstart, int nkeys,
             DTYPE *numval, char **comment, int *status)
  int ffpkne[edfg](fitsfile *fptr, char *keyroot, int nstart, int nkey,
                DTYPE *numval, int decimals, char **comment, > int *status)
  int ffpkyt(fitsfile *fptr, char *keyname, long intval, double frac,
             char *comment, > int *status)
\end{verbatim}
 Insert Keyword Routines: page~\pageref{FFIREC}

\begin{verbatim}
  int ffirec(fitsfile *fptr, int keynum, char *card, > int *status)
  int ffikys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffiky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
              > int *status)
  int ffiky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Read Keyword Routines: page~\pageref{FFGREC}

\begin{verbatim}
  int ffgrec(fitsfile *fptr, int keynum, > char *card, int *status)
  int ffgkyn(fitsfile *fptr, int keynum, > char *keyname, char *value,
             char *comment, int *status)
  int ffgcrd(fitsfile *fptr, char *keyname, > char *card, int *status)
  int ffgnxk(fitsfile *fptr, char **inclist, int ninc, char **exclist,
             int nexc,  > char *card, int  *status)
  int ffgkey(fitsfile *fptr, char *keyname, > char *value, char *comment,
             int *status)
  int ffgky(fitsfile *fptr, int datatype, char *keyname, > DTYPE *value,
       char *comment, int *status)
  int ffgkys(fitsfile *fptr, char *keyname, > char *value, char *comment,
             int *status);
  int ffgkls(fitsfile *fptr, char *keyname, > char **longstr, char *comment,
             int *status)
  int ffgky[ljed](fitsfile *fptr, char *keyname, > DTYPE *numval, char *comment,
             int *status)
  int ffgkns(fitsfile *fptr, char *keyname, int nstart, int nkeys,
             > char **value, int *nfound,  int *status)
  int ffgkn[ljed](fitsfile *fptr, char *keyname, int nstart, int nkeys,
                  > DTYPE *numval, int *nfound, int *status)
  int ffgkyt(fitsfile *fptr, char *keyname, > long *intval, double *frac,
             char *comment, int *status)
\end{verbatim}
 Modify Keyword Routines: page~\pageref{FFMREC}

\begin{verbatim}
  int ffmrec(fitsfile *fptr, int keynum, char *card, > int *status)
  int ffmcrd(fitsfile *fptr, char *keyname, char *card, > int *status)
  int ffmnam(fitsfile *fptr, char *oldname, char *newname, > int *status)
  int ffmcom(fitsfile *fptr, char *keyname, char *comment, > int *status)
  int ffmkys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status);
  int ffmky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
               > int *status)
  int ffmky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Update Keyword Routines: page~\pageref{FFUCRD}

\begin{verbatim}
  int ffucrd(fitsfile *fptr, char *keyname, char *card, > int *status)
  int ffukys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffuky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
               > int *status)
  int ffuky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Delete Keyword Routines: page~\pageref{FFDREC}

\begin{verbatim}
  int ffdrec(fitsfile *fptr, int   keynum,  > int *status)
  int ffdkey(fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}
 Define Data Scaling Parameters and Undefined Pixel Flags: page~\pageref{FFPSCL}

\begin{verbatim}
  int ffpscl(fitsfile *fptr, double scale, double zero, > int *status)
  int fftscl(fitsfile *fptr, int colnum, double scale, double zero,
             > int *status)
  int ffpnul(fitsfile *fptr, long nulval, > int *status)
  int ffsnul(fitsfile *fptr, int colnum, char *nulstr, > int *status)
  int fftnul(fitsfile *fptr, int colnum, long nulval, > int *status)
\end{verbatim}
 Write Image Data Routines: page~\pageref{FFPPR}

\begin{verbatim}
  int ffppr(fitsfile *fptr, int datatype, long firstelem, long nelements,
           DTYPE *array, int *status);
  int ffppr[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, > int *status);
  int ffppn[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, DTYPE nulval, > int *status);
  int ffpgp[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, > DTYPE *array, int *status)
  int ffppru(fitsfile *fptr, long group, long firstelem,
           long nelements, > int *status)
  int ffp2d[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long dim1, long naxis1,
           long naxis2, DTYPE *array, > int *status)
  int ffp3d[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long dim1, long dim2,
           long naxis1, long naxis2, long naxis3, DTYPE *array, > int *status)
  int ffpss[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long naxis, long *naxes,
           long *fpixel, long *lpixel, DTYPE *array, > int *status)
\end{verbatim}
 Read Image Data Routines: page~\pageref{FFGPV}

\begin{verbatim}
  int ffgpv(fitsfile *fptr, int  datatype, long firstelem, long nelements,
           DTYPE *nulval, > DTYPE *array, int *anynul, int *status)
  int ffgpv[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE nulval, > DTYPE *array, int *anynul, int *status)
  int ffgpf[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, > DTYPE *array, char *nularray, int *anynul, int *status)
  int ffggp[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, long firstelem,
           long nelements, > DTYPE *array, int *status)
  int ffg2d[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, DTYPE nulval, long dim1,
           long naxis1, long naxis2, > DTYPE *array,
           int *anynul, int *status)
  int ffg3d[b,i,ui,j,uj,k,e,d](fitsfile *fptr, long group, DTYPE nulval, long dim1,
           long dim2, long naxis1, long naxis2, long naxis3,
           > DTYPE *array, int *anynul, int *status)
  int ffgsv[b,i,ui,j,uj,k,e,d](fitsfile *fptr, int group, int naxis, long *naxes,
           long *fpixels, long *lpixels, long *inc, DTYPE nulval,
           > DTYPE *array, int *anynul, int *status)
  int ffgsf[b,i,ui,j,uj,k,e,d](fitsfile *fptr, int group, int naxis, long *naxes,
           long *fpixels, long *lpixels, long *inc, > DTYPE *array,
           char *nularray, int *anynul, int *status)
\end{verbatim}
 Table Column Information Routines: page~\pageref{FFGCNO}

\begin{verbatim}
  int ffgcno(fitsfile *fptr, int casesen, char *templt, > int *colnum,
           int *status)
  int ffgcnn(fitsfile *fptr, int casesen, char *templt, > char *colname,
           int *colnum, int *status)
  int ffgtcl(fitsfile *fptr, int colnum, > int *typecode, long *repeat,
           long *width, int *status)
  int ffgacl(fitsfile *fptr, int colnum, > char *ttype, long *tbcol,
           char *tunit, char *tform, double *scale, double *zero,
           char *nulstr, char *tdisp, int *status)
  int ffgbcl(fitsfile *fptr, int colnum, > char *ttype, char *tunit,
           char *typechar, long *repeat, double *scale, double *zero,
           long *nulval, char *tdisp, int  *status)
  int ffptdm( fitsfile *fptr, int colnum, int naxis, long *naxes,
            >  int *status)
  int ffgtdm(fitsfile *fptr, int colnum, int maxdim, > int *naxis,
           long *naxes, int *status)
  int ffgrsz(fitsfile *fptr, long *nrows, *status)
\end{verbatim}
 Low-Level Table Access Routines: page~\pageref{FFGTBB}

\begin{verbatim}
  int ffgtbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
           > unsigned char *values, int *status)
  int ffptbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
           unsigned char *values, > int *status)
\end{verbatim}
 Insert or Delete Rows and Columns Routines: page~\pageref{FFIROW}

\begin{verbatim}
  int ffirow(fitsfile *fptr, long firstrow, long nrows, > int *status)
  int ffdrow(fitsfile *fptr, long firstrow, long nrows, > int *status)
  int fficol(fitsfile *fptr, int colnum, char *ttype, char *tform,
            > int *status)
  int fficls(fitsfile *fptr, int colnum, int ncols, char **ttype,
           char **tform, > int *status)
  int ffdcol(fitsfile *fptr, int colnum, > int *status)
\end{verbatim}
 Write Column Data Routines: page~\pageref{FFPCLS}

\begin{verbatim}
  int ffpcl(fitsfile *fptr, int datatype, int colnum, long firstrow,
           long firstelem, long nelements, char **array, > int *status)
  int ffpcls(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, char **array, > int *status)
  int ffpcl[lb,i,ui,j,uj,k,e,d,c,m](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, > int *status)
  int ffpcn[b,i,ui,j,uj,k,e,d](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, DTYPE nulval,
           > int *status)
  int ffpclx(fitsfile *fptr, int colnum, long firstrow, long firstbit,
           long nbits, char *larray, > int *status)
  int ffpclu(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > int *status)
  int ffpdes(fitsfile *fptr, int colnum, long rownum, long repeat,
           long offset, > int *status)
  int ffpthp(fitsfile *fptr, long theap, > int *status)
\end{verbatim}
 Read Column Data Routines: page~\pageref{FFGCL}

\begin{verbatim}
  int ffgcv(fitsfile *fptr, int datatype, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *nulval, DTYPE *array,
           int *anynul, int *status)
  int ffgcl (fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char *array, int  *status)
  int ffgcvs(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, char *nulstr, > char **array, int *anynul,
           int *status)
  int ffgcv[b,i,ui,j,uj,k,e,d,c,m](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE nulval, > DTYPE *array,
           int *anynul, int *status)
  int ffgcfs(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char **array, char *nularray, int *anynul,
           int *status)
  int ffgcfl(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char *array, char *nularray, int *anynul,
           int *status)
  int ffgcf[b,i,ui,j,uj,k,e,d,c,m](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, > DTYPE *array,
           char *nularray, int *anynul, int *status)
  int ffgsv[b,i,ui,j,uj,k,e,d](fitsfile *fptr, int colnum, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, DTYPE nulval,
            > DTYPE *array, int *anynul, int *status)
  int ffgsf[b,i,ui,j,uj,k,e,d](fitsfile *fptr, int colnum, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, > DTYPE *array,
            char *nularray, int *anynul, int *status)
  int ffgcx(fitsfile *fptr, int colnum, long firstrow, long firstbit,
            long nbits, > char *larray, int *status)
  int ffgdes(fitsfile *fptr, int colnum, long rownum, > long *repeat,
           long *offset, int *status)
\end{verbatim}
 Celestial Coordinate System Routines: page~\pageref{FFGICS}

\begin{verbatim}
  int  ffgics (fitsfile *fptr, > double *xrefval, double *yrefval,
       double *xrefpix, double *yrefpix, double *xinc, double *yinc,
       double *rot, char *coordtype, int *status)
  int ffgtcs(fitsfile *fptr, int xcol, int ycol, > double *xrefval,
       double *yrefval, double *xrefpix, double *yrefpix, double *xinc,
       double *yinc, double *rot, char *coordtype, int *status)
  int ffwldp(double xpix, double ypix, double xrefval, double yrefval,
       double xrefpix, double yrefpix, double xinc, double yinc,
       double rot, char *coordtype, > double *xpos, double *ypos,
       int *status)
  int ffxypx(double xpos, double ypos, double xrefval, double yrefval,
       double xrefpix, double yrefpix, double xinc, double yinc,
       double rot, char *coordtype, double *xpix, double *ypix,
       int *status)
\end{verbatim}
 File Checksum Routines: page~\pageref{FFPCKS}

\begin{verbatim}
  int ffpcks(fitsfile *fptr, > int *status)
  int ffupck(fitsfile *fptr, > int *status)
  int ffvcks(fitsfile *fptr, > int *dataok, int *hduok, int *status)
  int ffgcks(fitsfile *fptr, > unsigned long *datasum, unsigned long *hdusum,
      int *status)
  int ffesum(unsigned long sum, int complm, > char *ascii)
  unsigned long ffdsum(char *ascii, int complm, > unsigned long *sum)
\end{verbatim}
 General Utility Routines: page~\pageref{FFVERS}

\begin{verbatim}
  float ffvers( > float *version)
  void ffghad(fitsfile *fptr, > long *chduaddr, long *nextaddr)
  void ffgerr(int status, > char *err_text)
  int  ffgmsg(char *err_msg)
  void ffpmsg(char *err_msg)
  void ffcmsg(void)
  void ffupch(char *string)
  void ffcmps(char *templt, char *string, int casesen, > int *match, int *exact)
  int fftkey(char *keyname, > int *status)
  int ffpsvc(char *card, > char *value, char *comment, int *status)
  int ffkeyn(char *keyroot, int value, > char *keyname, int *status)
  int ffnkey(int value, char *keyroot, > char *keyname, int *status)
  int ffdtyp(char *value, > char *dtype, int *status)
  int ffbnfm(char *tform, > int *typecode, long *repeat, long *width,
                int *status)
  int ffasfm(char *tform, > int *typecode, long *width, int *decimals,
             int *status)
  int ffgabc(int tfields, char **tform, int space, > long *rowlen,
            long *tbcol, int *status)
  int ffgthd(char *templt, > char *card, int *keytype, int *status)
\end{verbatim}

\chapter{ Parameter Definitions }

\begin{verbatim}
anynul   - set to TRUE (=1) if any returned values are undefined, else FALSE
array    - array of numerical data values to read or write
ascii    - encoded checksum string
bitpix   - bits per pixel. The following symbolic mnemonics are predefined:
               BYTE_IMG   =   8 (unsigned char)
               SHORT_IMG  =  16 (signed short integer)
               LONG_IMG   = 32 (signed long integer)
               FLOAT_IMG  = -32 (float)
               DOUBLE_IMG = -64 (double).
           Two additional values, USHORT_IMG and ULONG_IMG are also available
           for creating unsigned integer images.  These are equivalent to
           creating a signed integer image with BZERO offset keyword values
           of 32768 or 2147483648, respectively, which is the convention that
           FITS uses to store unsigned integers.
card     - header record to be read or written (80 char max, null-terminated)
casesen  - TRUE (=1) to force case-sensitive string matching, else FALSE (=0)
chduaddr - starting address (in bytes) of the CHDU
colname  - name of the column (null-terminated)
colnum   - column number (first column = 1)
comment  - the keyword comment field (72 char max, null-terminated)
complm   - should the checksum be complemented?
coordtype- type of coordinate projection (-SIN, -TAN, -ARC, -NCP,
           -GLS, -MER, or -AIT)
dataok   - was the data unit verification successful (=1) or
           not (= -1).  Equals zero if the DATASUM keyword is not present.
datasum  - 32-bit 1's complement checksum for the data unit
datatype - specifies the datatype of the value.  Allowed value are:
           TSTRING, TLOGICAL, TBIT, TBYTE, TSHORT, TUSHORT, TINT, TLONG, TULONG,
           TFLOAT, TDOUBLE, TCOMPLEX, and TDBLCOMPLEX
decimals - number of decimal places to be displayed
dim1     - declared size of the first dimension of the image or cube array
dim2     - declared size of the second dimension of the data cube array
dtype    - datatype of the keyword ('C', 'L', 'I',  or 'F')
                C = character string
                L = logical
                I = integer
                F = floating point number
err_msg  - error message on the internal stack (80 chars max)
err_text - error message string corresponding to error number (30 chars max)
exact    - TRUE (=1) if the strings match exactly;
           FALSE (=0) if wildcards are used
exclist  - array of pointers to keyword names to be excluded from search
extend   - TRUE (=1) if FITS file may have extensions, else FALSE (=0)
extname  - value of the EXTNAME keyword (null-terminated)
filename - name of the FITS file (null-terminated)
firstchar- starting byte in the row (first byte of row = 1)
firstelem- first element in a vector (ignored for ASCII tables)
firstrow - starting row number (first row of table = 1)
fpixels  - the first included pixel in each dimension (first pixel = 1)
fptr     - pointer to a 'fitsfile' structure describing the FITS file.
frac     - factional part of the keyword value
gcount   - number of groups in the primary array (usually = 1)
group    - data group number (=0 for non-grouped data)
hdunum   - sequence number of the HDU (Primary array = 1)
hduok    - was the HDU verification successful (=1) or
           not (= -1).  Equals zero if the CHECKSUM keyword is not present.
hdusum   - 32 bit 1's complement checksum for the entire CHDU
hdutype  - type of HDU: HDU_IMAGE (=0), HDU_ATABLE (=1), or HDU_BTABLE (=2)
history  - the HISTORY keyword comment string (70 char max, null-terminated)
inc      - sampling interval for pixels in each FITS dimension
inclist  - array of pointers to matching keyword names
infptr   - pointer to a 'fitsfile' structure describing the input FITS file.
intval   - integer part of the keyword value
iomode   - file access mode: either READONLY (=0) or READWRITE (=1)
keyname  - name of a keyword (8 char max, null-terminated)
keynum   - position of keyword in header (1st keyword = 1)
keyroot  - root string for the keyword name (5 char max, null-terminated)
keysexist- number of existing keyword records in the CHU
keytype  - header record type: -1=delete;  0=append or replace;
                   1=append; 2=this is the END keyword
longstr  - arbitrarily long string keyword value (null-terminated)
lpixels  - the last included pixel in each dimension (first pixel = 1)
match    - TRUE (=1) if the 2 strings match, else FALSE (=0)
maxdim   - maximum number of values to return
morekeys - space in the header for this many more keywords
naxes    - size of each dimension in the FITS array
naxis    - number of dimensions in the FITS array
naxis1   - length of the X/first axis of the FITS array
naxis2   - length of the Y/second axis of the FITS array
naxis3   - length of the Z/third axis of the FITS array
nchars   - number of characters to read or write
nelements- number of data elements to read or write
nexc     - number of names in the exclusion list (may = 0)
nextaddr - starting address (in bytes) of the HDU following the CHDU
nfound   - number of keywords found (highest keyword number)
nkeys    - number of keywords in the sequence
ninc     - number of names in the inclusion list
nmove    - number of HDUs to move (+ or -), relative to current position
nrows    - number of rows in the table
nstart   - first integer value
nularray - set to TRUE (=1) if corresponding data element is undefined
nulval   - numerical value to represent undefined pixels
nulstr   - character string used to represent undefined values in ASCII table
numval   - numerical data value, of the appropriate datatype
offset   -  byte offset in the heap to the first element of the vector
outfptr  - pointer to a 'fitsfile' structure describing the output FITS file.
pcount   - value of the PCOUNT keyword = size of binary table heap
repeat   - length of column vector (e.g. 12J); == 1 for ASCII table
rot      -  celestial coordinate rotation angle (degrees)
rowlen   - length of a table row, in characters or bytes
rownum   - number of the row (first row = 1)
scale    - linear scaling factor; true value = (FITS value) * scale + zero
simple   - TRUE (=1) if FITS file conforms to the Standard, else FALSE (=0)
space    - number of blank spaces to leave between ASCII table columns
status   - returned error status code (0 = OK)
sum      - 32 bit unsigned checksum value
tbcol    - byte position in row to start of column (1st col has tbcol = 1)
tdisp    - Fortran style display format for the table column
templt   - template string used in comparison (null-terminated)
tfields  - number of fields (columns) in the table
tform    - format of the column (null-terminated); allowed values are:
           ASCII tables:  Iw, Aw, Fww.dd, Eww.dd, or Dww.dd
           Binary tables: rL, rX, rB, rI, rJ, rA, rAw, rE, rD, rC, rM
           where 'w'=width of the field, 'd'=no. of decimals, 'r'=repeat count.
           When creating a binary table, 2 addition tform values are allowed:
           rU and rV for unsigned 16-bit and unsigned 32-bit integer, respectively.
theap    - zero indexed byte offset of starting address of the heap
           relative to the beginning of the binary table data
ttype    - label or name for table column (null-terminated)
tunit    - physical unit for table column (null-terminated)
typechar - symbolic code of the table column datatype
typecode - datatype code of the table column.  The negative of
           the value indicates a variable length array column.
                Datatype             typecode    Mnemonic
                bit, X                   1        TBIT
                byte, B                 11        TBYTE
                logical, L              14        TLOGICAL
                ASCII character, A      16        TSTRING
                short integer, I        21        TSHORT
                integer, J              41        TLONG
                real, E                 42        TFLOAT
                double precision, D     82        TDOUBLE
                complex, C              83        TCOMPLEX
                double complex, M      163        TDBLCOMPLEX
value    - the keyword value string (70 char max, null-terminated)
version  - current version number of the CFITSIO library
width    - width of the character string field
xcol     - number of the column containing the X coordinate values
xinc     - X axis coordinate increment at reference pixel (deg)
xpix     - X axis pixel location
xpos     - X axis celestial coordinate (usually RA) (deg)
xrefpix  - X axis reference pixel array location
xrefval  - X axis coordinate value at the reference pixel (deg)
ycol     - number of the column containing the X coordinate values
yinc     - Y axis coordinate increment at reference pixel (deg)
ypix     - y axis pixel location
ypos     - y axis celestial coordinate (usually DEC) (deg)
yrefpix  - Y axis reference pixel array location
yrefval  - Y axis coordinate value at the reference pixel (deg)
zero     - scaling offset; true value = (FITS value) * scale + zero
\end{verbatim}

\chapter{ CFITSIO Error Status Codes }

The following table lists all the error status codes used by CFITSIO.
Programmers are encouraged to use the symbolic mnemonics (defined in
the file fitsio.h) rather than the actual integer status values to
improve the readability of their code.

\begin{verbatim}
 Symbolic Const    Value     Meaning
 --------------    -----  -----------------------------------------
 SAME_FILE         101    input and output files are the same
 TOO_MANY_FILES    103    tried to open too many FITS files at once
 FILE_NOT_OPENED   104    could not open the named file
 FILE_NOT_CREATED  105    could not create the named file
 WRITE_ERROR       106    error writing to FITS file
 END_OF_FILE       107    tried to move past end of file
 READ_ERROR        108    error reading from FITS file
 FILE_NOT_CLOSED   110    could not close the file
 ARRAY_TOO_BIG     111    array dimensions exceed internal limit
 READONLY_FILE     112    Cannot write to readonly file

 HEADER_NOT_EMPTY  201    header already contains keywords
 KEY_NO_EXIST      202    keyword not found in header
 KEY_OUT_BOUNDS    203    keyword record number is out of bounds
 NO_VALUE          204    keyword value field is blank
 NO_QUOTE          205    string is missing the closing quote
 BAD_KEYCHAR       207    illegal character in keyword name or card
 BAD_ORDER         208    required keywords out of order
 NOT_POS_INT       209    keyword value is not a positive integer
 NO_END            210    couldn't find END keyword
 BAD_BITPIX        211    illegal BITPIX keyword value
 BAD_NAXIS         212    illegal NAXIS keyword value
 BAD_NAXES         213    illegal NAXISn keyword value
 BAD_PCOUNT        214    illegal PCOUNT keyword value
 BAD_GCOUNT        215    illegal GCOUNT keyword value
 BAD_TFIELDS       216    illegal TFIELDS keyword value
 NEG_WIDTH         217    negative table row size
 NEG_ROWS          218    negative number of rows in table
 COL_NOT_FOUND     219    column with this name not found in table
 BAD_SIMPLE        220    illegal value of SIMPLE keyword
 NO_SIMPLE         221    Primary array doesn't start with SIMPLE
 NO_BITPIX         222    Second keyword not BITPIX
 NO_NAXIS          223    Third keyword not NAXIS
 NO_NAXES          224    Couldn't find all the NAXISn keywords
 NO_XTENSION       225    HDU doesn't start with XTENSION keyword
 NOT_ATABLE        226    the CHDU is not an ASCII table extension
 NOT_BTABLE        227    the CHDU is not a binary table extension
 NO_PCOUNT         228    couldn't find PCOUNT keyword
 NO_GCOUNT         229    couldn't find GCOUNT keyword
 NO_TFIELDS        230    couldn't find TFIELDS keyword
 NO_TBCOL          231    couldn't find TBCOLn keyword
 NO_TFORM          232    couldn't find TFORMn keyword
 NOT_IMAGE         233    the CHDU is not an IMAGE extension
 BAD_TBCOL         234    TBCOLn keyword value < 0 or > rowlength
 NOT_TABLE         235    the CHDU is not a table
 COL_TOO_WIDE      236    column is too wide to fit in table
 COL_NOT_UNIQUE    237    more than 1 column name matches template
 BAD_ROW_WIDTH     241    sum of column widths not = NAXIS1
 UNKNOWN_EXT       251    unrecognizable FITS extension type
 UNKNOWN_REC       252    unrecognizable FITS record
 END_JUNK          253    END keyword is not blank
 BAD_TFORM         261    illegal TFORM format code
 BAD_TFORM_DTYPE   262    unrecognizable TFORM datatype code
 BAD_TDIM          263    illegal TDIMn keyword value

 BAD_HDU_NUM       301    HDU number < 1 or > MAXHDU
 BAD_COL_NUM       302    column number < 1 or > tfields
 NEG_FILE_POS      304    tried to move to negative byte location in file
 NEG_BYTES         306    tried to read or write negative number of bytes
 BAD_ROW_NUM       307    illegal starting row number in table
 BAD_ELEM_NUM      308    illegal starting element number in vector
 NOT_ASCII_COL     309    this is not an ASCII string column
 NOT_LOGICAL_COL   310    this is not a logical datatype column
 BAD_ATABLE_FORMAT 311    ASCII table column has wrong format
 BAD_BTABLE_FORMAT 312    Binary table column has wrong format
 NO_NULL           314    null value has not been defined
 NOT_VARI_LEN      317    this is not a variable length column
 BAD_DIMEN         320    illegal number of dimensions in array
 BAD_PIX_NUM       321    first pixel number greater than last pixel
 ZERO_SCALE        322    illegal BSCALE or TSCALn keyword = 0
 NEG_AXIS          323    illegal axis length < 1

 BAD_I2C           401    bad int to formatted string conversion
 BAD_F2C           402    bad float to formatted string conversion
 BAD_INTKEY        403    can't interprete keyword value as integer
 BAD_LOGICALKEY    404    can't interprete keyword value as logical
 BAD_FLOATKEY      405    can't interprete keyword value as float
 BAD_DOUBLEKEY     406    can't interprete keyword value as double
 BAD_C2I           407    bad formatted string to int conversion
 BAD_C2F           408    bad formatted string to float conversion
 BAD_C2D           409    bad formatted string to double conversion
 BAD_DATATYPE      410    illegal datatype code value
 BAD_DECIM         411    bad number of decimal places specified
 NUM_OVERFLOW      412    overflow during datatype conversion

 ANGLE_TOO_BIG     501    celestial angle too large for projection
 BAD_WCS_VAL       502    bad celestial coordinate or pixel value
 WCS_ERROR         503    error in celestial coordinate calculation
 BAD_WCS_PROJ      505    unsupported type of celestial projection
 NO_WCS_KEY        505    celestial coordinate keywords not found
\end{verbatim}
\end{document}

